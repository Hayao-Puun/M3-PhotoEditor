<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M3-PhotoEditor Ver.1.2</title>
    <!-- M3を活かしたシンプルでカッコイイWebアイコンの設定 -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='22' fill='black'/><rect x='12' y='12' width='76' height='76' rx='10' fill='none' stroke='white' stroke-width='1.5' opacity='0.4'/><text x='50%' y='52%' dominant-baseline='central' text-anchor='middle' fill='white' font-family='system-ui, sans-serif' font-weight='900' font-size='48' letter-spacing='-2'>M3</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <style>
        /* カスタムスクロールバー */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #171717; }
        ::-webkit-scrollbar-thumb { background: #404040; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #525252; }

        /* スライダー */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
            background: #d4d4d4; cursor: pointer; margin-top: -6px;
            box-shadow: 0 0 4px rgba(0,0,0,0.5); transition: transform 0.1s;
        }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.2); background: #fff; }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #404040; border-radius: 2px;
        }
        input[type=range]:focus { outline: none; }

        /* 数値入力 */
        input[type=number] {
            background: transparent; border: 1px solid transparent; color: #737373;
            font-family: monospace; width: 3.5rem; text-align: right; border-radius: 4px;
            padding: 0 4px; -moz-appearance: textfield;
        }
        input[type=number]:hover { border-color: #404040; color: #d4d4d4; }
        input[type=number]:focus { outline: none; border-color: #d4d4d4; color: #fff; background: #262626; }
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }

        /* キャンバス背景 */
        .canvas-container {
            background-image: 
                linear-gradient(45deg, #262626 25%, transparent 25%), 
                linear-gradient(-45deg, #262626 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #262626 75%), 
                linear-gradient(-45deg, transparent 75%, #262626 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #171717;
            overflow: hidden; position: relative;
        }

        #editor-canvas { transform-origin: center center; }

        .tool-btn.active { background-color: #e5e5e5; color: #171717; }

        /* アニメーション */
        @keyframes flash { 0% { opacity: 1; } 100% { opacity: 0; } }
        .flash-overlay { animation: flash 0.5s ease-out forwards; }

        /* チェックボックス */
        .custom-checkbox {
            appearance: none; background-color: #262626; border: 1px solid #404040;
            border-radius: 4px; width: 16px; height: 16px; display: inline-flex;
            align-items: center; justify-content: center; cursor: pointer; position: relative;
        }
        .custom-checkbox:checked { background-color: #3b82f6; border-color: #3b82f6; }
        .custom-checkbox:checked::after { content: '✔'; font-size: 10px; color: white; position: absolute; }

        /* カスタムセレクト */
        .custom-select {
            appearance: none; background-color: #262626; border: 1px solid #404040;
            color: #d4d4d4; padding: 4px 24px 4px 10px; border-radius: 6px; font-size: 12px;
            cursor: pointer; background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center; background-repeat: no-repeat; background-size: 1.5em 1.5em;
        }
        .custom-select:hover { border-color: #525252; color: #fff; }
        .custom-select:focus { outline: none; border-color: #a3a3a3; }

        /* 比較ボタンの長押し用スタイル */
        #compare-btn:active { transform: scale(0.95); }
    </style>
</head>
<body class="bg-neutral-950 text-neutral-300 font-sans h-screen flex flex-col overflow-hidden selection:bg-neutral-600 selection:text-white">

    <!-- ヘッダー -->
    <header class="h-14 bg-neutral-900 border-b border-neutral-800 flex items-center justify-between px-4 sm:px-6 shrink-0 z-20">
        <div class="flex items-center gap-4">
            <div class="flex items-center gap-2">
                <!-- ロゴ -->
                <svg width="24" height="24" viewBox="0 0 100 100" class="shrink-0">
                    <rect width="100" height="100" rx="22" fill="white"/>
                    <text x="50%" y="52%" dominant-baseline="central" text-anchor="middle" fill="black" font-family="sans-serif" font-weight="900" font-size="50" letter-spacing="-2">M3</text>
                </svg>
                <span class="font-medium tracking-widest text-neutral-100 text-sm hidden sm:block uppercase">PhotoEditor</span>
            </div>
            
            <!-- 履歴操作 -->
            <div class="flex items-center gap-1 ml-4 border-l border-neutral-700 pl-4">
                <button onclick="undo()" id="btn-undo" class="w-8 h-8 rounded flex items-center justify-center transition hover:bg-neutral-800 text-neutral-400 disabled:opacity-30 disabled:cursor-not-allowed" title="元に戻す (Ctrl+Z)" disabled>
                    <i class="ph ph-arrow-u-up-left text-lg"></i>
                </button>
                <button onclick="redo()" id="btn-redo" class="w-8 h-8 rounded flex items-center justify-center transition hover:bg-neutral-800 text-neutral-400 disabled:opacity-30 disabled:cursor-not-allowed" title="やり直す (Ctrl+Y)" disabled>
                    <i class="ph ph-arrow-u-up-right text-lg"></i>
                </button>
            </div>
        </div>
        
        <!-- ツールバー（中央） -->
        <div class="flex flex-col items-center absolute left-1/2 transform -translate-x-1/2 z-30 top-2">
            <div class="flex items-center gap-1 bg-neutral-800 p-1 rounded-lg border border-neutral-700 shadow-lg">
                <button id="tool-hand" class="tool-btn active w-9 h-9 rounded flex items-center justify-center transition hover:bg-neutral-700 hover:text-white text-neutral-400" title="移動・ズーム (Space)">
                    <i class="ph ph-hand-grabbing text-lg"></i>
                </button>
                <div class="w-px h-5 bg-neutral-600 mx-1"></div>
                <button id="tool-select" class="tool-btn w-9 h-9 rounded flex items-center justify-center transition hover:bg-neutral-700 hover:text-white text-neutral-400" title="矩形選択・部分補正 (Shiftで正方形)">
                    <i class="ph ph-selection-plus text-lg"></i>
                </button>
                <button id="tool-circle" class="tool-btn w-9 h-9 rounded flex items-center justify-center transition hover:bg-neutral-700 hover:text-white text-neutral-400" title="円形選択・部分補正 (Shiftで正円)">
                    <i class="ph ph-circle-dashed text-lg"></i>
                </button>
                <button id="tool-crop" class="tool-btn w-9 h-9 rounded flex items-center justify-center transition hover:bg-neutral-700 hover:text-white text-neutral-400" title="トリミング (C)">
                    <i class="ph ph-crop text-lg"></i>
                </button>
                <div class="w-px h-5 bg-neutral-600 mx-1"></div>
                <button onclick="resetView()" class="w-9 h-9 rounded flex items-center justify-center transition hover:bg-neutral-700 hover:text-white text-neutral-400" title="表示リセット (Fit)">
                    <i class="ph ph-corners-out text-lg"></i>
                </button>
            </div>

            <!-- クロップオプション -->
            <div id="crop-options" class="mt-2 bg-neutral-900/90 backdrop-blur border border-neutral-700 rounded-lg p-1.5 flex items-center gap-2 hidden shadow-xl">
                <span class="text-[10px] text-neutral-400 uppercase tracking-wider font-bold px-1">Ratio</span>
                <select id="aspect-ratio-select" class="custom-select">
                    <option value="free">フリー</option>
                    <option value="original">オリジナル</option>
                    <option value="1:1">1:1 (正方形)</option>
                    <option value="16:9">16:9</option>
                    <option value="4:3">4:3</option>
                    <option value="3:2">3:2</option>
                </select>
            </div>
        </div>

        <div class="flex items-center gap-4">
            <label for="upload-input" class="cursor-pointer flex items-center gap-2 px-4 py-1.5 rounded-full bg-neutral-800 hover:bg-neutral-700 transition text-xs font-medium text-neutral-200 border border-neutral-700 whitespace-nowrap">
                <i class="ph ph-upload-simple"></i>
                <span class="hidden sm:inline">開く</span>
            </label>
            <input type="file" id="upload-input" class="hidden" accept="image/*">
            
            <button id="download-btn" class="flex items-center gap-2 px-4 py-1.5 rounded-full bg-neutral-100 hover:bg-white text-neutral-900 transition text-xs font-medium disabled:opacity-50 disabled:cursor-not-allowed whitespace-nowrap" disabled>
                <i class="ph ph-download-simple"></i>
                <span class="hidden sm:inline">保存</span>
            </button>
        </div>
    </header>

    <!-- メインエリア -->
    <div class="flex flex-1 overflow-hidden">
        
        <!-- 左サイドバー（プリセット） -->
        <aside class="w-16 bg-neutral-900 border-r border-neutral-800 flex flex-col items-center py-4 gap-4 shrink-0 z-10 hidden sm:flex overflow-y-auto overflow-x-hidden custom-scroll">
            
            <div class="flex flex-col gap-3 pb-4 pt-2">
                <button onclick="applyPreset('bw')" class="w-10 h-10 rounded-lg bg-neutral-800 hover:bg-neutral-700 flex items-center justify-center transition group relative" title="モノクロ">
                    <span class="font-serif font-bold text-xs">BW</span>
                </button>
                <button onclick="applyPreset('warm')" class="w-10 h-10 rounded-lg bg-neutral-800 hover:bg-neutral-700 flex items-center justify-center transition group relative" title="ウォーム">
                    <span class="text-orange-300 text-lg">●</span>
                </button>
                <button onclick="applyPreset('cool')" class="w-10 h-10 rounded-lg bg-neutral-800 hover:bg-neutral-700 flex items-center justify-center transition group relative" title="クール">
                    <span class="text-blue-300 text-lg">●</span>
                </button>
                <button onclick="applyPreset('film')" class="w-10 h-10 rounded-lg bg-neutral-800 hover:bg-neutral-700 flex items-center justify-center transition group relative" title="フィルム調">
                    <i class="ph ph-film-strip"></i>
                </button>
                <button onclick="applyPreset('vivid')" class="w-10 h-10 rounded-lg bg-neutral-800 hover:bg-neutral-700 flex items-center justify-center transition group relative" title="ビビッド">
                    <i class="ph ph-sparkle text-yellow-400"></i>
                </button>
                <button onclick="applyPreset('retro')" class="w-10 h-10 rounded-lg bg-neutral-800 hover:bg-neutral-700 flex items-center justify-center transition group relative" title="レトロ">
                    <i class="ph ph-camera-rotate text-orange-400"></i>
                </button>
                <button onclick="applyPreset('matte')" class="w-10 h-10 rounded-lg bg-neutral-800 hover:bg-neutral-700 flex items-center justify-center transition group relative" title="マット">
                    <i class="ph ph-cloud-fog text-neutral-400"></i>
                </button>
                <button onclick="applyPreset('dramatic')" class="w-10 h-10 rounded-lg bg-neutral-800 hover:bg-neutral-700 flex items-center justify-center transition group relative" title="ドラマチック">
                    <i class="ph ph-lightning text-purple-400"></i>
                </button>
            </div>
        </aside>

        <!-- キャンバスエリア -->
        <main class="flex-1 bg-neutral-950 relative overflow-hidden canvas-container flex items-center justify-center" id="drop-zone">
            <!-- 初期メッセージ -->
            <div id="placeholder-msg" class="text-center pointer-events-none absolute inset-0 flex flex-col items-center justify-center z-10">
                <i class="ph ph-image text-6xl text-neutral-700 mb-4"></i>
                <p class="text-neutral-500 font-light">ここに画像をドロップ<br>または「開く」を選択</p>
            </div>
            
            <!-- キャンバスラッパー -->
            <div id="canvas-wrapper" class="absolute w-full h-full flex items-center justify-center pointer-events-none">
                <canvas id="editor-canvas" class="hidden pointer-events-auto cursor-grab"></canvas>
            </div>

            <!-- アクションバー -->
            <div id="action-bar" class="absolute bottom-8 left-1/2 transform -translate-x-1/2 bg-neutral-800 px-4 py-2 rounded-full shadow-xl flex items-center gap-3 border border-neutral-700 hidden z-30">
                <span id="action-label" class="text-xs font-medium text-neutral-300 mr-2">範囲選択中</span>
                <button onclick="applyCurrentAction()" class="bg-blue-600 hover:bg-blue-500 text-white text-xs px-3 py-1.5 rounded-full font-medium transition flex items-center gap-1">
                    <i class="ph ph-check"></i> 適用
                </button>
                <button onclick="cancelAction()" class="bg-neutral-700 hover:bg-neutral-600 text-neutral-300 text-xs px-3 py-1.5 rounded-full font-medium transition flex items-center gap-1">
                    <i class="ph ph-x"></i> キャンセル
                </button>
            </div>

            <!-- 比較ボタン（左下） -->
            <button id="compare-btn" class="absolute bottom-6 left-6 z-40 bg-neutral-800/90 backdrop-blur text-neutral-300 px-4 py-2 rounded-full text-xs font-bold border border-neutral-700 shadow-lg select-none active:bg-blue-600 active:text-white transition flex items-center gap-2 hidden group" title="長押しで比較">
                <i class="ph ph-arrows-left-right text-lg"></i>
                <span>比較</span>
            </button>

            <!-- ズームインジケーター -->
            <div id="zoom-indicator" class="absolute bottom-6 right-6 bg-black/70 text-white text-xs px-2 py-1 rounded opacity-0 transition-opacity pointer-events-none font-mono z-20">
                100%
            </div>
            
            <!-- ロード中 -->
            <div id="loading" class="absolute inset-0 bg-neutral-950/80 hidden items-center justify-center z-50">
                <i class="ph ph-spinner animate-spin text-3xl text-neutral-400"></i>
            </div>
        </main>

        <!-- 右サイドバー -->
        <aside class="w-80 bg-neutral-900 border-l border-neutral-800 flex flex-col shrink-0 overflow-y-auto z-10 custom-scroll">
            
            <!-- 部分調整パネル -->
            <div id="panel-local" class="px-6 py-5 border-b border-neutral-800 bg-neutral-900/50 relative">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xs font-bold tracking-widest text-blue-400 uppercase flex items-center gap-2">
                        <i class="ph ph-selection-plus"></i> Local Adjustments
                    </h2>
                    <span class="text-[10px] text-neutral-500 bg-neutral-800 px-2 py-0.5 rounded">選択範囲のみ</span>
                </div>
                
                <div id="local-disabled-overlay" class="absolute inset-0 bg-neutral-900/80 z-20 flex items-center justify-center backdrop-blur-[1px] transition-opacity duration-300">
                    <p class="text-xs text-neutral-400 text-center px-4">
                        <i class="ph ph-cursor-click mb-1 block text-lg"></i>
                        範囲選択ツールまたは<br>トリミングツールを使用してください
                    </p>
                </div>

                <div class="mb-5 flex items-center justify-between">
                    <label for="invert-mask" class="text-xs text-neutral-400 cursor-pointer select-none">選択範囲を反転 (外側に適用)</label>
                    <input type="checkbox" id="invert-mask" class="custom-checkbox" onchange="requestAnimationFrame(() => render())">
                </div>

                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition">ぼかし</span>
                        <input type="number" id="num-localBlur" value="0" min="0" max="50" step="1">
                    </div>
                    <input type="range" id="localBlur" min="0" max="50" value="0" step="1" class="control-slider">
                </div>

                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition">モザイク</span>
                        <input type="number" id="num-localMosaic" value="0" min="0" max="100">
                    </div>
                    <input type="range" id="localMosaic" min="0" max="100" value="0" step="1" class="control-slider">
                </div>
            </div>

            <!-- 全体調整パネル -->
            <div class="px-6 py-5 border-b border-neutral-800">
                <h2 class="text-xs font-bold tracking-widest text-neutral-500 uppercase mb-4">Global Light & Color</h2>
                <p class="text-[10px] text-neutral-500 mb-4 bg-neutral-800/50 p-2 rounded border border-neutral-800">
                    <i class="ph ph-info"></i> 項目名をダブルクリックで0にリセット
                </p>
                
                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition">露光量</span>
                        <input type="number" id="num-brightness" value="0" min="-100" max="100">
                    </div>
                    <input type="range" id="brightness" min="-100" max="100" value="0" class="control-slider">
                </div>

                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition">コントラスト</span>
                        <input type="number" id="num-contrast" value="0" min="-100" max="100">
                    </div>
                    <input type="range" id="contrast" min="-100" max="100" value="0" class="control-slider">
                </div>

                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition">ハイライト</span>
                        <input type="number" id="num-highlights" value="0" min="-100" max="100">
                    </div>
                    <input type="range" id="highlights" min="-100" max="100" value="0" class="control-slider">
                </div>

                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition">シャドウ</span>
                        <input type="number" id="num-shadows" value="0" min="-100" max="100">
                    </div>
                    <input type="range" id="shadows" min="-100" max="100" value="0" class="control-slider">
                </div>

                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition">彩度 (Saturation)</span>
                        <input type="number" id="num-saturation" value="0" min="-100" max="100">
                    </div>
                    <input type="range" id="saturation" min="-100" max="100" value="0" class="control-slider">
                </div>

                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition text-blue-300">自然な彩度 (Vibrance)</span>
                        <input type="number" id="num-vibrance" value="0" min="-100" max="100">
                    </div>
                    <input type="range" id="vibrance" min="-100" max="100" value="0" class="control-slider">
                </div>

                 <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition">色温度</span>
                        <input type="number" id="num-temperature" value="0" min="-50" max="50">
                    </div>
                    <div class="relative h-1 w-full rounded-full bg-gradient-to-r from-blue-900 via-neutral-600 to-orange-900 mb-2 top-3 pointer-events-none"></div>
                    <input type="range" id="temperature" min="-50" max="50" value="0" class="control-slider relative z-10">
                </div>
            </div>

            <div class="px-6 py-5">
                <h2 class="text-xs font-bold tracking-widest text-neutral-500 uppercase mb-4">Creative & Effects</h2>

                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition">色相 (Hue)</span>
                        <input type="number" id="num-hue" value="0" min="-180" max="180">
                    </div>
                    <div class="relative h-1 w-full rounded-full bg-gradient-to-r from-red-500 via-green-500 to-blue-500 mb-2 top-3 pointer-events-none opacity-50"></div>
                    <input type="range" id="hue" min="-180" max="180" value="0" class="control-slider relative z-10">
                </div>

                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition">セピア (Sepia)</span>
                        <input type="number" id="num-sepia" value="0" min="0" max="100">
                    </div>
                    <input type="range" id="sepia" min="0" max="100" value="0" class="control-slider">
                </div>

                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition">反転 (Invert)</span>
                        <input type="number" id="num-invert" value="0" min="0" max="100">
                    </div>
                    <input type="range" id="invert" min="0" max="100" value="0" class="control-slider">
                </div>

                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition">全体ぼかし (Blur)</span>
                        <input type="number" id="num-blur" value="0" min="0" max="20" step="0.5">
                    </div>
                    <input type="range" id="blur" min="0" max="20" value="0" step="0.5" class="control-slider">
                </div>
                
                <div class="w-full h-px bg-neutral-800 my-4"></div>

                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition">粒子 (Grain)</span>
                        <input type="number" id="num-grain" value="0" min="0" max="100">
                    </div>
                    <input type="range" id="grain" min="0" max="100" value="0" class="control-slider">
                </div>

                 <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition">周辺減光 (Vignette)</span>
                        <input type="number" id="num-vignette" value="0" min="0" max="100">
                    </div>
                    <input type="range" id="vignette" min="0" max="100" value="0" class="control-slider">
                </div>
            </div>

            <!-- フッター情報 -->
            <div class="mt-auto p-6 text-center shrink-0">
                <p class="text-[10px] text-neutral-500 font-medium">M3-PhotoEditor Ver.1.2</p>
                <p class="text-[10px] text-neutral-600 mt-1 tracking-wider">created by Hayao</p>
            </div>
        </aside>
    </div>

    <script>
        // --- 状態管理クラス ---
        class HistoryManager {
            constructor() {
                this.undoStack = []; this.redoStack = []; this.limit = 25;
            }
            push(state) {
                const safeState = {
                    imageData: state.imageData,
                    globalParams: JSON.parse(JSON.stringify(state.globalParams))
                };
                this.undoStack.push(safeState);
                if (this.undoStack.length > this.limit) this.undoStack.shift();
                this.redoStack = []; 
                this.updateButtons();
            }
            undo() {
                if (this.undoStack.length <= 1) return null;
                const current = this.undoStack.pop(); 
                this.redoStack.push(current);
                this.updateButtons(); 
                return this.undoStack[this.undoStack.length - 1];
            }
            redo() {
                if (this.redoStack.length === 0) return null;
                const next = this.redoStack.pop(); 
                this.undoStack.push(next);
                this.updateButtons(); 
                return next;
            }
            updateButtons() {
                const uBtn = document.getElementById('btn-undo');
                const rBtn = document.getElementById('btn-redo');
                if (uBtn) uBtn.disabled = this.undoStack.length <= 1;
                if (rBtn) rBtn.disabled = this.redoStack.length === 0;
            }
            reset() { this.undoStack = []; this.redoStack = []; this.updateButtons(); }
        }

        // --- メインロジック ---
        const CANVAS_PAD = 0; 

        const canvas = document.getElementById('editor-canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const uploadInput = document.getElementById('upload-input');
        const downloadBtn = document.getElementById('download-btn');
        const placeholderMsg = document.getElementById('placeholder-msg');
        const loadingOverlay = document.getElementById('loading');
        const dropZone = document.getElementById('drop-zone');
        const invertCheckbox = document.getElementById('invert-mask');
        const cropOptions = document.getElementById('crop-options');
        const aspectRatioSelect = document.getElementById('aspect-ratio-select');
        const compareBtn = document.getElementById('compare-btn');
        
        const toolBtns = {
            hand: document.getElementById('tool-hand'),
            select: document.getElementById('tool-select'),
            circle: document.getElementById('tool-circle'),
            crop: document.getElementById('tool-crop')
        };
        const actionBar = document.getElementById('action-bar');
        const actionLabel = document.getElementById('action-label');
        const localPanelOverlay = document.getElementById('local-disabled-overlay');

        const history = new HistoryManager();
        let isImageLoaded = false;
        let currentMode = 'hand'; 
        let currentFileName = 'photo_edited';
        let baseImage = null; 
        
        let viewState = { scale: 1, x: 0, y: 0, isDragging: false, lastX: 0, lastY: 0 };
        let selectionState = { active: false, dragMode: null, startX: 0, startY: 0, initialRect: null, initialRotation: 0, anchorGlobal: null, shape: 'rect', rotation: 0, rect: { x: 0, y: 0, w: 0, h: 0 } };

        // パラメータ拡張
        const globalParams = { 
            brightness: 0, contrast: 0, saturation: 0, vibrance: 0, temperature: 0, 
            hue: 0, sepia: 0, invert: 0, blur: 0,
            grain: 0, vignette: 0, highlights: 0, shadows: 0 
        };
        const localParams = { blur: 0, mosaic: 0 };

        function updateCanvasTransform() {
            canvas.style.transform = `translate(${viewState.x}px, ${viewState.y}px) scale(${viewState.scale})`;
            const indicator = document.getElementById('zoom-indicator');
            indicator.textContent = Math.round(viewState.scale * 100) + '%';
            indicator.style.opacity = '1';
            clearTimeout(window.zoomTimer);
            window.zoomTimer = setTimeout(() => indicator.style.opacity = '0', 1500);
        }

        window.resetView = () => {
            if(!isImageLoaded || !baseImage) return;
            const containerW = dropZone.clientWidth; const containerH = dropZone.clientHeight;
            const scaleW = (containerW - 40) / canvas.width; const scaleH = (containerH - 40) / canvas.height;
            viewState.scale = Math.min(scaleW, scaleH, 1); viewState.x = 0; viewState.y = 0;
            updateCanvasTransform();
        };

        function setMode(mode) {
            currentMode = mode;
            Object.keys(toolBtns).forEach(k => toolBtns[k].classList.toggle('active', k === mode));
            if (mode === 'hand') { canvas.style.cursor = 'grab'; canvasWrapper.style.cursor = 'grab'; cancelAction(); } 
            else { canvas.style.cursor = 'crosshair'; canvasWrapper.style.cursor = 'crosshair'; }
            if (mode === 'select' || mode === 'circle') { localPanelOverlay.classList.add('opacity-0', 'pointer-events-none'); cropOptions.classList.add('hidden'); } 
            else { localPanelOverlay.classList.remove('opacity-0', 'pointer-events-none'); }
            if (mode === 'crop') { cancelAction(); localPanelOverlay.classList.remove('opacity-0', 'pointer-events-none'); localPanelOverlay.querySelector('p').innerHTML = '<i class="ph ph-crop mb-1 block text-lg"></i>トリミング範囲を選択して<br>「適用」を押してください'; cropOptions.classList.remove('hidden'); } 
            else if (mode !== 'select' && mode !== 'circle') { localPanelOverlay.querySelector('p').innerHTML = '<i class="ph ph-cursor-click mb-1 block text-lg"></i>範囲選択ツールまたは<br>トリミングツールを使用してください'; cropOptions.classList.add('hidden'); }
        }
        
        toolBtns.hand.addEventListener('click', () => setMode('hand'));
        toolBtns.select.addEventListener('click', () => setMode('select'));
        toolBtns.circle.addEventListener('click', () => setMode('circle'));
        toolBtns.crop.addEventListener('click', () => setMode('crop'));

        function getElementId(prefix, key) { return prefix ? prefix + key.charAt(0).toUpperCase() + key.slice(1) : key; }

        function setupParamListeners(paramsObj, prefix) {
            Object.keys(paramsObj).forEach(key => {
                const id = getElementId(prefix, key);
                const slider = document.getElementById(id); const numInput = document.getElementById('num-' + id);
                if (slider && numInput) {
                    slider.addEventListener('input', (e) => {
                        paramsObj[key] = parseFloat(e.target.value); numInput.value = e.target.value;
                        requestAnimationFrame(() => render());
                    });
                    if (!prefix) {
                        slider.addEventListener('change', () => { if (isImageLoaded) saveHistoryState(); });
                    }
                    numInput.addEventListener('input', (e) => {
                        let val = parseFloat(e.target.value); if (isNaN(val)) return;
                        paramsObj[key] = val; slider.value = val;
                        requestAnimationFrame(() => render());
                    });
                    if (!prefix) {
                        numInput.addEventListener('change', () => { if (isImageLoaded) saveHistoryState(); });
                    }

                    // --- ダブルクリックで0にリセット ---
                    const wrapper = slider.parentElement;
                    const label = wrapper.querySelector('span');
                    if (label) {
                        label.style.cursor = 'pointer';
                        label.title = 'ダブルクリックでリセット';
                        label.addEventListener('dblclick', (e) => {
                            e.preventDefault(); // 選択防止
                            paramsObj[key] = 0;
                            slider.value = 0;
                            numInput.value = 0;
                            if (isImageLoaded) saveHistoryState();
                            render();
                        });
                    }
                }
            });
        }
        setupParamListeners(globalParams, '');
        setupParamListeners(localParams, 'local');

        uploadInput.addEventListener('change', (e) => loadFile(e.target.files[0]));
        dropZone.addEventListener('dragover', (e) => e.preventDefault());
        dropZone.addEventListener('drop', (e) => { e.preventDefault(); if (e.dataTransfer.files.length > 0) loadFile(e.dataTransfer.files[0]); });

        function loadFile(file) {
            if (!file || !file.type.startsWith('image/')) return;
            currentFileName = file.name.replace(/\.[^/.]+$/, "");
            loadingOverlay.classList.remove('hidden'); loadingOverlay.classList.add('flex');
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = async () => {
                    baseImage = await createImageBitmap(img);
                    // Paddingを0に
                    canvas.width = baseImage.width + CANVAS_PAD * 2; canvas.height = baseImage.height + CANVAS_PAD * 2;
                    isImageLoaded = true; placeholderMsg.style.display = 'none'; canvas.classList.remove('hidden'); downloadBtn.disabled = false;
                    compareBtn.classList.remove('hidden'); // 比較ボタン表示
                    history.reset(); 
                    saveHistoryState();
                    resetView(); setMode('hand'); resetParams(globalParams); resetParams(localParams);
                    loadingOverlay.classList.add('hidden'); loadingOverlay.classList.remove('flex');
                    render();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        async function saveHistoryState() {
            if (!isImageLoaded) return;
            const tmpCanvas = document.createElement('canvas');
            tmpCanvas.width = baseImage.width; tmpCanvas.height = baseImage.height;
            const tmpCtx = tmpCanvas.getContext('2d');
            tmpCtx.drawImage(baseImage, 0, 0);
            const imageData = tmpCtx.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height);
            history.push({ imageData: imageData, globalParams: JSON.parse(JSON.stringify(globalParams)) });
        }

        async function restoreState(state) {
            if (!state) return;
            baseImage = await createImageBitmap(state.imageData);
            canvas.width = baseImage.width + CANVAS_PAD * 2; canvas.height = baseImage.height + CANVAS_PAD * 2;
            Object.assign(globalParams, JSON.parse(JSON.stringify(state.globalParams)));
            updateInputDisplays(globalParams, ''); 
            resetParams(localParams);
            cancelAction(); 
            render();
        }

        window.undo = async () => { const state = history.undo(); if (state) await restoreState(state); };
        window.redo = async () => { const state = history.redo(); if (state) await restoreState(state); };

        window.applyCurrentAction = async () => {
            if (!selectionState.active) return;
            loadingOverlay.classList.remove('hidden'); loadingOverlay.classList.add('flex');
            setTimeout(async () => {
                if (currentMode === 'select' || currentMode === 'circle') await applyLocalEffect();
                else if (currentMode === 'crop') await applyCrop();
                loadingOverlay.classList.add('hidden'); loadingOverlay.classList.remove('flex');
                const flash = document.createElement('div');
                flash.className = 'absolute inset-0 bg-white pointer-events-none flash-overlay z-50';
                document.body.appendChild(flash);
                setTimeout(() => flash.remove(), 500);
            }, 10);
        };

        window.cancelAction = () => {
            selectionState.active = false; selectionState.rect = { x: 0, y: 0, w: 0, h: 0 }; selectionState.rotation = 0;
            actionBar.classList.add('hidden'); resetParams(localParams); invertCheckbox.checked = false; render();
        };

        function rotatePoint(x, y, cx, cy, angle) {
            const cos = Math.cos(angle); const sin = Math.sin(angle);
            const dx = x - cx; const dy = y - cy;
            return { x: cx + dx * cos - dy * sin, y: cy + dx * sin + dy * cos };
        }

        async function applyLocalEffect() {
            const tmpCanvas = document.createElement('canvas');
            tmpCanvas.width = baseImage.width; tmpCanvas.height = baseImage.height;
            const tmpCtx = tmpCanvas.getContext('2d');
            const w = tmpCanvas.width; const h = tmpCanvas.height;
            const rect = selectionState.rect; const params = localParams;
            const isInvert = invertCheckbox.checked;
            const rotation = selectionState.rotation;
            const cx = rect.x + rect.w / 2; const cy = rect.y + rect.h / 2;
            const adjRectX = rect.x; const adjRectY = rect.y;

            if (params.mosaic > 0 || params.blur > 0) {
                tmpCtx.drawImage(baseImage, 0, 0);
                const effectCanvas = document.createElement('canvas'); effectCanvas.width = w; effectCanvas.height = h;
                const effectCtx = effectCanvas.getContext('2d'); effectCtx.drawImage(baseImage, 0, 0);
                if (params.blur > 0) {
                    const bC = document.createElement('canvas'); bC.width = w; bC.height = h;
                    const bCtx = bC.getContext('2d'); bCtx.filter = `blur(${params.blur}px)`;
                    bCtx.drawImage(effectCanvas, 0, 0); effectCtx.clearRect(0,0,w,h); effectCtx.drawImage(bC, 0, 0);
                }
                if (params.mosaic > 0) {
                    const sF = Math.max(0.005, 1 - (params.mosaic / 105)); const sw = Math.floor(w * sF); const sh = Math.floor(h * sF);
                    const offC = document.createElement('canvas'); offC.width = Math.max(1, sw); offC.height = Math.max(1, sh);
                    const offCtx = offC.getContext('2d'); offCtx.drawImage(effectCanvas, 0, 0, offC.width, offC.height);
                    effectCtx.imageSmoothingEnabled = false; effectCtx.drawImage(offC, 0, 0, offC.width, offC.height, 0, 0, w, h); effectCtx.imageSmoothingEnabled = true;
                }
                tmpCtx.save(); tmpCtx.translate(cx, cy); tmpCtx.rotate(rotation); tmpCtx.translate(-cx, -cy);
                tmpCtx.beginPath();
                if (selectionState.shape === 'circle') tmpCtx.ellipse(cx, cy, Math.abs(rect.w / 2), Math.abs(rect.h / 2), 0, 0, 2 * Math.PI);
                else tmpCtx.rect(adjRectX, adjRectY, rect.w, rect.h); 
                if (isInvert) {
                    tmpCtx.setTransform(1, 0, 0, 1, 0, 0); tmpCtx.clearRect(0, 0, w, h); tmpCtx.drawImage(effectCanvas, 0, 0);
                    tmpCtx.save(); tmpCtx.translate(cx, cy); tmpCtx.rotate(rotation); tmpCtx.translate(-cx, -cy);
                    tmpCtx.beginPath();
                    if (selectionState.shape === 'circle') tmpCtx.ellipse(cx, cy, Math.abs(rect.w/2), Math.abs(rect.h/2), 0, 0, 2*Math.PI);
                    else tmpCtx.rect(adjRectX, adjRectY, rect.w, rect.h);
                    tmpCtx.clip(); tmpCtx.translate(cx, cy); tmpCtx.rotate(-rotation); tmpCtx.translate(-cx, -cy);
                    tmpCtx.drawImage(baseImage, 0, 0); tmpCtx.restore();
                } else {
                    tmpCtx.clip(); tmpCtx.translate(cx, cy); tmpCtx.rotate(-rotation); tmpCtx.translate(-cx, -cy);
                    tmpCtx.drawImage(effectCanvas, 0, 0); tmpCtx.restore();
                }
                tmpCtx.restore();
            }
            baseImage = await createImageBitmap(tmpCanvas);
            await saveHistoryState(); cancelAction();
        }

        async function applyCrop() {
            const rect = selectionState.rect; const rotation = selectionState.rotation;
            if (rect.w < 1 || rect.h < 1) return;
            const cx = rect.x + rect.w / 2; const cy = rect.y + rect.h / 2;
            const w = Math.abs(rect.w); const h = Math.abs(rect.h);
            const cropCanvas = document.createElement('canvas'); cropCanvas.width = w; cropCanvas.height = h;
            const cCtx = cropCanvas.getContext('2d');
            cCtx.translate(w / 2, h / 2); cCtx.rotate(-rotation); cCtx.drawImage(baseImage, -cx, -cy);
            baseImage = await createImageBitmap(cropCanvas);
            canvas.width = w + CANVAS_PAD * 2; canvas.height = h + CANVAS_PAD * 2;
            await saveHistoryState(); cancelAction(); resetView();
        }

        // ピクセルレベル操作（ハイライト、シャドウ、バイブランス）の統合
        function applyPixelManipulations(ctx, width, height, highlights, shadows, vibrance) {
            if (highlights === 0 && shadows === 0 && vibrance === 0) return;
            const imgData = ctx.getImageData(CANVAS_PAD, CANVAS_PAD, baseImage.width, baseImage.height);
            const data = imgData.data; const len = data.length;
            
            // Vibrance adjustment factor (-1 to 1)
            const vAdj = -1 * (vibrance / 100);

            for (let i = 0; i < len; i += 4) {
                let r = data[i];
                let g = data[i+1];
                let b = data[i+2];

                // Highlights / Shadows
                if (highlights !== 0 || shadows !== 0) {
                    const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b; 
                    const nL = lum / 255;
                    let adj = (highlights !== 0 ? nL*nL*nL * (highlights/100) * 255 : 0) + 
                              (shadows !== 0 ? Math.pow(1-nL,3) * (shadows/100) * 255 : 0);
                    if (adj !== 0) {
                        r = Math.max(0, Math.min(255, r + adj));
                        g = Math.max(0, Math.min(255, g + adj));
                        b = Math.max(0, Math.min(255, b + adj));
                    }
                }

                // Vibrance (Natural Saturation)
                if (vibrance !== 0) {
                    const max = Math.max(r, g, b);
                    const avg = (r + g + b) / 3;
                    const amt = ((Math.abs(max - avg) * 2 / 255) * vAdj) * (1 + vAdj);
                    
                    if (r !== max) r += (max - r) * amt;
                    if (g !== max) g += (max - g) * amt;
                    if (b !== max) b += (max - b) * amt;
                }
                
                data[i] = r;
                data[i+1] = g;
                data[i+2] = b;
            }
            ctx.putImageData(imgData, CANVAS_PAD, CANVAS_PAD);
        }

        function render(isExport = false, isCompare = false) {
            if (!isImageLoaded || !baseImage) return;
            const w = canvas.width; const h = canvas.height; const gp = globalParams;
            ctx.clearRect(0, 0, w, h);
            
            // 比較モードならエフェクトなしで描画して終了
            if (isCompare) {
                ctx.drawImage(baseImage, CANVAS_PAD, CANVAS_PAD);
                return;
            }

            // コンテキストフィルタ (GPU加速が効くもの)
            // Blurは最後にかける
            let filterString = `brightness(${100 + gp.brightness}%) contrast(${100 + gp.contrast}%) saturate(${100 + gp.saturation}%)`;
            if (gp.hue !== 0) filterString += ` hue-rotate(${gp.hue}deg)`;
            if (gp.sepia !== 0) filterString += ` sepia(${gp.sepia}%)`;
            if (gp.invert !== 0) filterString += ` invert(${gp.invert}%)`;
            if (gp.blur !== 0) filterString += ` blur(${gp.blur}px)`;

            ctx.filter = filterString;
            ctx.drawImage(baseImage, CANVAS_PAD, CANVAS_PAD); 
            ctx.filter = 'none';

            // ピクセル操作 (CPU処理)
            if (gp.highlights !== 0 || gp.shadows !== 0 || gp.vibrance !== 0) {
                applyPixelManipulations(ctx, w, h, gp.highlights, gp.shadows, gp.vibrance);
            }

            // 選択範囲描画 (エフェクト適用のためのバッファ処理)
            if (selectionState.active && (currentMode === 'select' || currentMode === 'circle')) {
                const lp = localParams; const rect = selectionState.rect; const isInvert = invertCheckbox.checked;
                const rot = selectionState.rotation; const cx = rect.x + rect.w/2; const cy = rect.y + rect.h/2;
                if (lp.mosaic > 0 || lp.blur > 0) {
                    const eC = document.createElement('canvas'); eC.width = baseImage.width; eC.height = baseImage.height;
                    const eCtx = eC.getContext('2d'); eCtx.drawImage(canvas, CANVAS_PAD, CANVAS_PAD, baseImage.width, baseImage.height, 0, 0, baseImage.width, baseImage.height);
                    if (lp.blur > 0) {
                        const bC = document.createElement('canvas'); bC.width = eC.width; bC.height = eC.height;
                        const bCtx = bC.getContext('2d'); bCtx.filter = `blur(${lp.blur}px)`; bCtx.drawImage(eC,0,0); eCtx.clearRect(0,0,eC.width,eC.height); eCtx.drawImage(bC,0,0);
                    }
                    if (lp.mosaic > 0) {
                        const sF = Math.max(0.005, 1-(lp.mosaic/105)); const offC = document.createElement('canvas'); offC.width=Math.max(1,eC.width*sF); offC.height=Math.max(1,eC.height*sF);
                        const offCtx = offC.getContext('2d'); offCtx.drawImage(eCtx.canvas,0,0,offC.width,offC.height); eCtx.imageSmoothingEnabled=false; eCtx.drawImage(offC,0,0,offC.width,offC.height,0,0,eC.width,eC.height); eCtx.imageSmoothingEnabled=true;
                    }
                    ctx.save(); ctx.translate(cx, cy); ctx.rotate(rot); ctx.translate(-cx, -cy);
                    ctx.beginPath();
                    if (selectionState.shape === 'circle') ctx.ellipse(cx, cy, Math.abs(rect.w/2), Math.abs(rect.h/2), 0, 0, 2*Math.PI);
                    else ctx.rect(rect.x, rect.y, rect.w, rect.h);
                    if (isInvert) {
                        ctx.restore(); ctx.save(); ctx.drawImage(eC, CANVAS_PAD, CANVAS_PAD); ctx.restore();
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(rot); ctx.translate(-cx, -cy); ctx.beginPath();
                        if (selectionState.shape === 'circle') ctx.ellipse(cx, cy, Math.abs(rect.w/2), Math.abs(rect.h/2), 0, 0, 2*Math.PI); else ctx.rect(rect.x, rect.y, rect.w, rect.h);
                        ctx.clip(); ctx.translate(cx, cy); ctx.rotate(-rot); ctx.translate(-cx, -cy);
                        ctx.drawImage(canvas, 0, 0); 
                    } else {
                        ctx.clip(); ctx.translate(cx, cy); ctx.rotate(-rot); ctx.translate(-cx, -cy); ctx.drawImage(eC, CANVAS_PAD, CANVAS_PAD);
                    }
                    ctx.restore();
                }
            }
            if (selectionState.active && currentMode === 'crop' && !isExport) {
                const r = selectionState.rect; const rot = selectionState.rotation;
                ctx.save(); ctx.translate(r.x+r.w/2, r.y+r.h/2); ctx.rotate(rot); ctx.translate(-(r.x+r.w/2), -(r.y+r.h/2));
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2 / viewState.scale; ctx.setLineDash([8 / viewState.scale, 8 / viewState.scale]);
                ctx.strokeRect(r.x, r.y, r.w, r.h); ctx.setLineDash([]); drawHandles(ctx, r); ctx.restore();
            }
            ctx.save();
            if (gp.temperature !== 0) {
                ctx.globalCompositeOperation = 'overlay'; ctx.fillStyle = gp.temperature > 0 ? `rgba(255, 160, 0, ${Math.abs(gp.temperature)/150})` : `rgba(0, 100, 255, ${Math.abs(gp.temperature)/150})`;
                ctx.fillRect(CANVAS_PAD, CANVAS_PAD, baseImage.width, baseImage.height);
            }
            if (gp.grain > 0) drawGrain(ctx, baseImage.width, baseImage.height, gp.grain, CANVAS_PAD, CANVAS_PAD);
            if (gp.vignette > 0) {
                ctx.globalCompositeOperation = 'multiply'; const iw = baseImage.width, ih = baseImage.height, r = Math.max(iw, ih)/1.5;
                const g = ctx.createRadialGradient(CANVAS_PAD+iw/2, CANVAS_PAD+ih/2, r * 0.4, CANVAS_PAD+iw/2, CANVAS_PAD+ih/2, r);
                g.addColorStop(0, 'rgba(0,0,0,0)'); g.addColorStop(1, `rgba(0,0,0,${gp.vignette/100})`);
                ctx.fillStyle = g; ctx.fillRect(CANVAS_PAD, CANVAS_PAD, iw, ih);
            }
            ctx.restore();
            if (!isExport && selectionState.active && currentMode !== 'crop') {
                const r = selectionState.rect; const rot = selectionState.rotation; const cx = r.x+r.w/2, cy = r.y+r.h/2;
                ctx.save(); ctx.translate(cx, cy); ctx.rotate(rot); ctx.translate(-cx, -cy);
                ctx.strokeStyle = 'white'; ctx.lineWidth = 1.5 / viewState.scale; ctx.setLineDash([5/viewState.scale, 5/viewState.scale]);
                if (selectionState.shape === 'circle') { ctx.beginPath(); ctx.ellipse(cx, cy, Math.abs(r.w/2), Math.abs(r.h/2), 0, 0, 2*Math.PI); ctx.stroke(); }
                else ctx.strokeRect(r.x, r.y, r.w, r.h);
                ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineDashOffset = 5 / viewState.scale;
                if (selectionState.shape === 'circle') { ctx.beginPath(); ctx.ellipse(cx, cy, Math.abs(r.w/2), Math.abs(r.h/2), 0, 0, 2*Math.PI); ctx.stroke(); }
                else ctx.strokeRect(r.x, r.y, r.w, r.h);
                drawHandles(ctx, r); ctx.restore();
            }
        }

        function drawHandles(ctx, rect) {
            const hs = 8 / viewState.scale; ctx.fillStyle = 'white'; ctx.strokeStyle = 'black'; ctx.lineWidth = 1 / viewState.scale;
            const { x, y, w, h } = rect; const handles = [{x,y}, {x:x+w,y}, {x:x+w,y:y+h}, {x,y:y+h}];
            handles.forEach(h => { ctx.fillRect(h.x-hs/2, h.y-hs/2, hs, hs); ctx.strokeRect(h.x-hs/2, h.y-hs/2, hs, hs); });
            const cx = x + w / 2, ry = y - 25 / viewState.scale;
            ctx.beginPath(); ctx.moveTo(cx, y); ctx.lineTo(cx, ry); ctx.stroke();
            ctx.beginPath(); ctx.arc(cx, ry, 5 / viewState.scale, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
        }

        function drawGrain(tCtx, w, h, s, ox = 0, oy = 0) {
            const imageData = grainCtx.createImageData(256, 256); const d = imageData.data, a = (s/100)*100;
            for (let i = 0; i < d.length; i += 4) { const v = (Math.random()-0.5)*a; d[i]=128+v; d[i+1]=128+v; d[i+2]=128+v; d[i+3]=255; }
            grainCtx.putImageData(imageData, 0, 0); tCtx.globalCompositeOperation = 'overlay';
            tCtx.fillStyle = tCtx.createPattern(grainCanvas, 'repeat'); tCtx.fillRect(ox, oy, w, h); tCtx.globalCompositeOperation = 'source-over';
        }
        const grainCanvas = document.createElement('canvas'); grainCanvas.width = 256; grainCanvas.height = 256;
        const grainCtx = grainCanvas.getContext('2d');

        dropZone.addEventListener('wheel', (e) => {
            if (!isImageLoaded) return; e.preventDefault();
            const ns = viewState.scale * (1 - e.deltaY * 0.001);
            viewState.scale = Math.min(Math.max(ns, 0.05), 50); updateCanvasTransform();
        }, { passive: false });

        function getHandleUnderMouse(mx, my) {
            if (!selectionState.active) return null;
            const r = selectionState.rect; const cx = r.x+r.w/2, cy = r.y+r.h/2;
            const p = rotatePoint(mx, my, cx, cy, -selectionState.rotation);
            const hs = 10 / viewState.scale;
            if (Math.abs(p.x-r.x)<hs && Math.abs(p.y-r.y)<hs) return 'tl';
            if (Math.abs(p.x-(r.x+r.w))<hs && Math.abs(p.y-r.y)<hs) return 'tr';
            if (Math.abs(p.x-(r.x+r.w))<hs && Math.abs(p.y-(r.y+r.h))<hs) return 'br';
            if (Math.abs(p.x-r.x)<hs && Math.abs(p.y-(r.y+r.h))<hs) return 'bl';
            if (Math.abs(p.x-cx)<hs && Math.abs(p.y-(r.y-25/viewState.scale))<hs) return 'rotate';
            return null;
        }

        function isInsideRect(mx, my) {
            if (!selectionState.active) return false;
            const r = selectionState.rect; const cx = r.x+r.w/2, cy = r.y+r.h/2;
            const p = rotatePoint(mx, my, cx, cy, -selectionState.rotation);
            return p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h;
        }

        canvas.addEventListener('mousedown', (e) => {
            if (!isImageLoaded) return;
            if (currentMode === 'hand' || e.button === 1 || e.spaceKey) { viewState.isDragging = true; viewState.lastX = e.clientX; viewState.lastY = e.clientY; canvas.style.cursor = 'grabbing'; return; }
            const br = canvas.getBoundingClientRect(); const mx = (e.clientX - br.left) / viewState.scale, my = (e.clientY - br.top) / viewState.scale;
            const handle = getHandleUnderMouse(mx, my);
            if (handle) {
                selectionState.dragMode = handle === 'rotate' ? 'rotate' : 'resize-' + handle; selectionState.active = true;
                const rect = selectionState.rect; const cx = rect.x+rect.w/2, cy = rect.y+rect.h/2;
                let ax = rect.x, ay = rect.y;
                if (handle === 'tl') { ax = rect.x + rect.w; ay = rect.y + rect.h; } else if (handle === 'tr') { ax = rect.x; ay = rect.y + rect.h; } else if (handle === 'bl') { ax = rect.x + rect.w; ay = rect.y; } else if (handle === 'br') { ax = rect.x; ay = rect.y; }
                selectionState.anchorGlobal = rotatePoint(ax, ay, cx, cy, selectionState.rotation);
            } else if (isInsideRect(mx, my)) { selectionState.dragMode = 'move'; selectionState.active = true; } 
            else { selectionState.dragMode = 'create'; selectionState.active = false; selectionState.shape = (currentMode === 'circle') ? 'circle' : 'rect'; selectionState.rotation = 0; actionBar.classList.add('hidden'); }
            selectionState.startX = mx; selectionState.startY = my; selectionState.initialRect = { ...selectionState.rect }; selectionState.initialRotation = selectionState.rotation;
            if (selectionState.dragMode === 'create') selectionState.rect = { x: mx, y: my, w: 0, h: 0 };
        });

        window.addEventListener('mousemove', (e) => {
            if (!isImageLoaded) return;
            if (viewState.isDragging) { const dx = e.clientX - viewState.lastX, dy = e.clientY - viewState.lastY; viewState.x += dx; viewState.y += dy; viewState.lastX = e.clientX; viewState.lastY = e.clientY; updateCanvasTransform(); return; }
            const br = canvas.getBoundingClientRect(); const mx = (e.clientX - br.left) / viewState.scale, my = (e.clientY - br.top) / viewState.scale;
            const handle = getHandleUnderMouse(mx, my);
            if (handle) canvas.style.cursor = handle === 'rotate' ? 'alias' : (handle === 'tl' || handle === 'br' ? 'nwse-resize' : 'nesw-resize');
            else if (isInsideRect(mx, my)) canvas.style.cursor = 'move';
            else canvas.style.cursor = 'crosshair';
            if (!selectionState.dragMode) return;
            if (selectionState.dragMode === 'rotate') { const r = selectionState.rect, cx = r.x+r.w/2, cy = r.y+r.h/2; selectionState.rotation = Math.atan2(my - cy, mx - cx) + Math.PI / 2; render(); return; }
            if (selectionState.dragMode === 'move') { selectionState.rect.x = selectionState.initialRect.x + (mx - selectionState.startX); selectionState.rect.y = selectionState.initialRect.y + (my - selectionState.startY); } 
            else if (selectionState.dragMode === 'create') {
                let w = mx - selectionState.startX, h = my - selectionState.startY;
                const ratio = (currentMode === 'crop') ? (aspectRatioSelect.value === 'free' ? null : (aspectRatioSelect.value === 'original' ? baseImage.width / baseImage.height : parseFloat(aspectRatioSelect.value.split(':')[0]) / parseFloat(aspectRatioSelect.value.split(':')[1]))) : null;
                if (ratio) { if (Math.abs(w/ratio) < Math.abs(h)) h = w/ratio; else w = h*ratio; } else if (e.shiftKey) { const size = Math.max(Math.abs(w), Math.abs(h)); w = w >= 0 ? size : -size; h = h >= 0 ? size : -size; }
                selectionState.rect = { x: w > 0 ? selectionState.startX : selectionState.startX + w, y: h > 0 ? selectionState.startY : selectionState.startY + h, w: Math.abs(w), h: Math.abs(h) };
                selectionState.active = true;
            } else if (selectionState.dragMode.startsWith('resize')) {
                const type = selectionState.dragMode.split('-')[1], anchor = selectionState.anchorGlobal, rot = selectionState.rotation;
                const lp = rotatePoint(mx, my, anchor.x, anchor.y, -rot);
                let nw = lp.x, nh = lp.y; if (type === 'tl' || type === 'bl') nw = -lp.x; if (type === 'tl' || type === 'tr') nh = -lp.y;
                const ratio = (currentMode === 'crop') ? (aspectRatioSelect.value === 'free' ? null : (aspectRatioSelect.value === 'original' ? baseImage.width / baseImage.height : parseFloat(aspectRatioSelect.value.split(':')[0]) / parseFloat(aspectRatioSelect.value.split(':')[1]))) : null;
                if (ratio) nh = nw / ratio; else if (e.shiftKey) { const s = Math.max(Math.abs(nw), Math.abs(nh)); nw = s; nh = s; }
                let lcx = nw / 2, lcy = nh / 2; if (type === 'tl' || type === 'bl') lcx = -nw / 2; if (type === 'tl' || type === 'tr') lcy = -nh / 2;
                const newCenter = rotatePoint(anchor.x + lcx, anchor.y + lcy, anchor.x, anchor.y, rot);
                selectionState.rect = { x: newCenter.x - Math.abs(nw)/2, y: newCenter.y - Math.abs(nh)/2, w: Math.abs(nw), h: Math.abs(nh) };
            }
            render();
        });

        window.addEventListener('mouseup', () => {
            if (viewState.isDragging) { viewState.isDragging = false; canvas.style.cursor = currentMode === 'hand' ? 'grab' : 'crosshair'; }
            if (selectionState.dragMode) {
                selectionState.dragMode = null;
                if (selectionState.rect.w > 5 && selectionState.rect.h > 5) {
                    selectionState.active = true; actionBar.classList.remove('hidden');
                    if (currentMode === 'crop') { actionLabel.textContent = 'トリミング範囲'; localPanelOverlay.classList.remove('opacity-0', 'pointer-events-none'); }
                    else { actionLabel.textContent = '選択範囲'; localPanelOverlay.classList.add('opacity-0', 'pointer-events-none'); resetParams(localParams); }
                } else selectionState.active = false;
                render();
            }
        });

        function resetParams(p) { Object.keys(p).forEach(k => p[k] = 0); updateInputDisplays(p, p === localParams ? 'local' : ''); }
        function updateInputDisplays(p, pre) { Object.keys(p).forEach(k => { const id = getElementId(pre, k); const s = document.getElementById(id); const n = document.getElementById('num-'+id); if (s) s.value = p[k]; if (n) n.value = p[k]; }); }
        
        downloadBtn.addEventListener('click', () => {
            if (!isImageLoaded) return; render(true);
            
            // 日本時間でのタイムスタンプ生成 (YYYYMMDDHHmmss)
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const ts = `${year}${month}${day}${hours}${minutes}${seconds}`;

            const link = document.createElement('a'); 
            link.download = `M3-${ts}.jpg`;
            // JPEG形式で品質0.92で出力
            link.href = canvas.toDataURL('image/jpeg', 0.92); 
            link.click(); 
            render();
        });

        window.applyPreset = (type) => {
            if (!isImageLoaded) return;
            if (type === 'default' && !confirm('リセットしますか？')) return;
            resetParams(globalParams);
            switch(type) {
                case 'bw': 
                    globalParams.saturation = -100; 
                    globalParams.contrast = 20; 
                    globalParams.grain = 20;
                    globalParams.vignette = 20;
                    break;
                case 'warm': 
                    globalParams.temperature = 30; 
                    globalParams.saturation = 10; 
                    globalParams.vibrance = 10;
                    globalParams.sepia = 10;
                    break;
                case 'cool': 
                    globalParams.temperature = -30; 
                    globalParams.contrast = 10; 
                    globalParams.vibrance = 10;
                    globalParams.hue = -5;
                    break;
                case 'film': 
                    globalParams.contrast = -10; 
                    globalParams.brightness = 5; 
                    globalParams.saturation = -10; 
                    globalParams.vibrance = -10;
                    globalParams.temperature = 10; 
                    globalParams.grain = 40; 
                    globalParams.vignette = 40; 
                    globalParams.blur = 0.5;
                    break;
                case 'vivid': 
                    globalParams.saturation = 20; 
                    globalParams.vibrance = 40;
                    globalParams.contrast = 15; 
                    break;
                case 'retro': 
                    globalParams.temperature = 20; 
                    globalParams.contrast = -10; 
                    globalParams.saturation = -20; 
                    globalParams.sepia = 40;
                    globalParams.grain = 30; 
                    globalParams.vignette = 30;
                    break;
                case 'matte': 
                    globalParams.saturation = -20; 
                    globalParams.contrast = -10; 
                    globalParams.highlights = -40; 
                    globalParams.shadows = 40; 
                    globalParams.vibrance = -10;
                    break;
                case 'dramatic': 
                    globalParams.contrast = 30; 
                    globalParams.vibrance = 30;
                    globalParams.vignette = 50; 
                    globalParams.highlights = 10; 
                    globalParams.shadows = -40; 
                    globalParams.grain = 25;
                    break;
            }
            saveHistoryState(); 
            updateInputDisplays(globalParams, ''); render();
        };

        updateInputDisplays(globalParams, ''); updateInputDisplays(localParams, 'local');
    </script>
</body>
</html>
