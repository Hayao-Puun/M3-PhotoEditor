<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M3-PhotoEditor Ver.2.13</title>
    <!-- M3を活かしたシンプルでカッコイイWebアイコンの設定 -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='22' fill='black'/><rect x='12' y='12' width='76' height='76' rx='10' fill='none' stroke='white' stroke-width='1.5' opacity='0.4'/><text x='50%' y='50%' dominant-baseline='central' text-anchor='middle' fill='white' font-family='system-ui, sans-serif' font-weight='900' font-size='48' letter-spacing='-2'>M3</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <style>
        /* カスタムスクロールバー */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #171717; }
        ::-webkit-scrollbar-thumb { background: #404040; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #525252; }

        /* スライダー */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
            background: #d4d4d4; cursor: pointer; margin-top: -6px;
            box-shadow: 0 0 4px rgba(0,0,0,0.5); transition: transform 0.1s;
        }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.2); background: #fff; }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #404040; border-radius: 2px;
        }
        input[type=range]:focus { outline: none; }

        /* 数値入力 */
        input[type=number] {
            background: transparent; border: 1px solid transparent; color: #737373;
            font-family: monospace; width: 3.5rem; text-align: right; border-radius: 4px;
            padding: 0 4px; -moz-appearance: textfield;
        }
        input[type=number]:hover { border-color: #404040; color: #d4d4d4; }
        input[type=number]:focus { outline: none; border-color: #d4d4d4; color: #fff; background: #262626; }
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }

        /* キャンバス背景 */
        .canvas-container {
            background-image: 
                linear-gradient(45deg, #262626 25%, transparent 25%), 
                linear-gradient(-45deg, #262626 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #262626 75%), 
                linear-gradient(-45deg, transparent 75%, #262626 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #171717;
            overflow: hidden; position: relative;
        }

        #editor-canvas { transform-origin: center center; }

        .tool-btn.active { background-color: #e5e5e5; color: #171717; }

        /* アニメーション */
        @keyframes flash { 0% { opacity: 1; } 100% { opacity: 0; } }
        .flash-overlay { animation: flash 0.5s ease-out forwards; }
        
        /* AI Tag Styles */
        .ai-tag {
            border: 1px solid #404040;
            background-color: #262626;
            color: #a3a3a3;
            transition: all 0.2s;
            cursor: pointer;
            user-select: none;
            font-size: 11px;
            white-space: nowrap;
        }
        .ai-tag:hover { border-color: #8b5cf6; background-color: #4c1d95; color: #fff; }
        .ai-tag.selected {
            background-color: #8b5cf6; /* Violet-500 */
            border-color: #8b5cf6;
            color: white;
            box-shadow: 0 0 8px rgba(139, 92, 246, 0.4);
        }

        /* カテゴリ見出し & パラメータラベル */
        .category-header, .param-label {
            cursor: pointer;
            transition: color 0.2s;
            position: relative;
        }
        .category-header:hover, .param-label:hover {
            color: #d4d4d4;
        }
        .category-header:hover::after, .param-label:hover::after {
            content: ' ↺';
            font-size: 10px;
            opacity: 0.7;
            margin-left: 4px;
        }

        /* チェックボックス */
        .custom-checkbox {
            appearance: none; background-color: #262626; border: 1px solid #404040;
            border-radius: 4px; width: 16px; height: 16px; display: inline-flex;
            align-items: center; justify-content: center; cursor: pointer; position: relative;
        }
        .custom-checkbox:checked { background-color: #3b82f6; border-color: #3b82f6; }
        .custom-checkbox:checked::after { content: '✔'; font-size: 10px; color: white; position: absolute; }

        /* カスタムセレクト */
        .custom-select {
            appearance: none; background-color: #262626; border: 1px solid #404040;
            color: #d4d4d4; padding: 4px 24px 4px 10px; border-radius: 6px; font-size: 12px;
            cursor: pointer; background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center; background-repeat: no-repeat; background-size: 1.5em 1.5em;
        }
        .custom-select:hover { border-color: #525252; color: #fff; }
        .custom-select:focus { outline: none; border-color: #a3a3a3; }

        /* 比較ボタンの長押し用スタイル */
        #compare-btn:active { background-color: #2563eb !important; color: white !important; transform: scale(0.95); }
        
        /* サイドバー切り替えアニメーション */
        .sidebar-content {
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        .sidebar-content.hidden-content {
            display: none;
            opacity: 0;
            transform: translateX(-10px);
        }
        .sidebar-content.active-content {
            display: flex;
            opacity: 1;
            transform: translateX(0);
        }

        /* マイスタイルボタン */
        .mystyle-btn {
            @apply w-full h-8 rounded bg-neutral-800 hover:bg-neutral-700 text-neutral-300 text-xs flex items-center justify-between px-2 transition group relative;
        }
        .mystyle-delete {
            @apply opacity-0 group-hover:opacity-100 hover:text-red-400 transition p-1;
        }

        /* オーバーレイ */
        #local-disabled-overlay {
            pointer-events: none;
        }
        #local-disabled-overlay p {
            background: rgba(23, 23, 23, 0.9);
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid #404040;
        }
    </style>
</head>
<body class="bg-neutral-950 text-neutral-300 font-sans h-screen flex flex-col overflow-hidden selection:bg-neutral-600 selection:text-white">

    <!-- ヘッダー -->
    <header class="h-14 bg-neutral-900 border-b border-neutral-800 flex items-center justify-between px-4 sm:px-6 shrink-0 z-20">
        <div class="flex items-center gap-4">
            <div class="flex items-center gap-2">
                <!-- ロゴ -->
                <svg width="24" height="24" viewBox="0 0 100 100" class="shrink-0">
                    <rect width="100" height="100" rx="22" fill="white"/>
                    <text x="50%" y="50%" dominant-baseline="central" text-anchor="middle" fill="black" font-family="sans-serif" font-weight="900" font-size="50" letter-spacing="-2">M3</text>
                </svg>
                <span class="font-medium tracking-widest text-neutral-100 text-sm hidden sm:block uppercase">PhotoEditor</span>
            </div>
            
            <!-- 履歴操作 -->
            <div class="flex items-center gap-1 ml-4 border-l border-neutral-700 pl-4">
                <button onclick="undo()" id="btn-undo" class="w-8 h-8 rounded flex items-center justify-center transition hover:bg-neutral-800 text-neutral-400 disabled:opacity-30 disabled:cursor-not-allowed" title="元に戻す (Ctrl+Z)" disabled>
                    <i class="ph ph-arrow-u-up-left text-lg"></i>
                </button>
                <button onclick="redo()" id="btn-redo" class="w-8 h-8 rounded flex items-center justify-center transition hover:bg-neutral-800 text-neutral-400 disabled:opacity-30 disabled:cursor-not-allowed" title="やり直す (Ctrl+Y)" disabled>
                    <i class="ph ph-arrow-u-up-right text-lg"></i>
                </button>
            </div>
        </div>
        
        <!-- ツールバー（中央） -->
        <div class="flex flex-col items-center absolute left-1/2 transform -translate-x-1/2 z-30 top-2">
            <div class="flex items-center gap-1 bg-neutral-800 p-1 rounded-lg border border-neutral-700 shadow-lg">
                <button id="tool-hand" class="tool-btn active w-9 h-9 rounded flex items-center justify-center transition hover:bg-neutral-700 hover:text-white text-neutral-400" title="移動・ズーム (Space)">
                    <i class="ph ph-hand-grabbing text-lg"></i>
                </button>
                <div class="w-px h-5 bg-neutral-600 mx-1"></div>
                <button id="tool-select" class="tool-btn w-9 h-9 rounded flex items-center justify-center transition hover:bg-neutral-700 hover:text-white text-neutral-400" title="矩形選択・部分補正 (Shiftで正方形)">
                    <i class="ph ph-selection-plus text-lg"></i>
                </button>
                <button id="tool-circle" class="tool-btn w-9 h-9 rounded flex items-center justify-center transition hover:bg-neutral-700 hover:text-white text-neutral-400" title="円形選択・部分補正 (Shiftで正円)">
                    <i class="ph ph-circle-dashed text-lg"></i>
                </button>
                <button id="tool-crop" class="tool-btn w-9 h-9 rounded flex items-center justify-center transition hover:bg-neutral-700 hover:text-white text-neutral-400" title="トリミング (C)">
                    <i class="ph ph-crop text-lg"></i>
                </button>
                <div class="w-px h-5 bg-neutral-600 mx-1"></div>
                <button onclick="resetView()" class="w-9 h-9 rounded flex items-center justify-center transition hover:bg-neutral-700 hover:text-white text-neutral-400" title="表示リセット (Fit)">
                    <i class="ph ph-corners-out text-lg"></i>
                </button>
            </div>

            <!-- クロップオプション -->
            <div id="crop-options" class="mt-2 bg-neutral-900/90 backdrop-blur border border-neutral-700 rounded-lg p-1.5 flex items-center gap-2 hidden shadow-xl">
                <span class="text-[10px] text-neutral-400 uppercase tracking-wider font-bold px-1">Ratio</span>
                <select id="aspect-ratio-select" class="custom-select">
                    <option value="free">フリー</option>
                    <option value="original">オリジナル</option>
                    <option value="1:1">1:1 (正方形)</option>
                    <option value="16:9">16:9</option>
                    <option value="4:3">4:3</option>
                    <option value="3:2">3:2</option>
                </select>
            </div>
        </div>

        <div class="flex items-center gap-4">
            <label for="upload-input" class="cursor-pointer flex items-center gap-2 px-4 py-1.5 rounded-full bg-neutral-800 hover:bg-neutral-700 transition text-xs font-medium text-neutral-200 border border-neutral-700 whitespace-nowrap">
                <i class="ph ph-upload-simple"></i>
                <span class="hidden sm:inline">開く</span>
            </label>
            <input type="file" id="upload-input" class="hidden" accept="image/*">
            
            <button id="download-btn" class="flex items-center gap-2 px-4 py-1.5 rounded-full bg-neutral-100 hover:bg-white text-neutral-900 transition text-xs font-medium disabled:opacity-50 disabled:cursor-not-allowed whitespace-nowrap" disabled>
                <i class="ph ph-download-simple"></i>
                <span class="hidden sm:inline">保存</span>
            </button>
        </div>
    </header>

    <!-- メインエリア -->
    <div class="flex flex-1 overflow-hidden relative">
        
        <!-- 左サイドバー（プリセット & AIパネル） -->
        <aside class="w-16 bg-neutral-900 border-r border-neutral-800 flex flex-col items-center py-4 gap-4 shrink-0 z-10 hidden sm:flex overflow-y-auto overflow-x-hidden custom-scroll transition-all duration-300" id="left-sidebar" style="width: 5rem;">
            
            <!-- Magic Style ボタン -->
            <button onclick="toggleAIMode()" id="btn-magic-style" class="w-10 h-10 rounded-xl bg-neutral-800 border border-neutral-700 text-blue-400 hover:bg-blue-900/30 hover:text-blue-300 hover:border-blue-500/50 flex items-center justify-center transition-all shadow-lg group relative mb-2 shrink-0" title="Magic Style (AI自動アレンジ)">
                <i class="ph ph-sparkle text-xl group-hover:scale-110 transition-transform"></i>
            </button>

            <div class="w-8 h-px bg-neutral-800 shrink-0"></div>

            <!-- 通常フィルター一覧 (Mode A) -->
            <div id="sidebar-presets" class="flex-col gap-3 pb-4 flex w-full items-center sidebar-content active-content">
                <span class="text-[10px] font-bold text-neutral-500 tracking-widest mt-1">STYLE</span>
                
                <button onclick="applyPreset('film')" class="w-10 h-10 rounded-lg bg-neutral-800 hover:bg-neutral-700 flex items-center justify-center transition group relative" title="フィルム調">
                    <i class="ph ph-film-strip"></i>
                </button>
                <button onclick="applyPreset('retro')" class="w-10 h-10 rounded-lg bg-neutral-800 hover:bg-neutral-700 flex items-center justify-center transition group relative" title="レトロ">
                    <i class="ph ph-camera-rotate text-orange-400"></i>
                </button>
                <button onclick="applyPreset('vivid')" class="w-10 h-10 rounded-lg bg-neutral-800 hover:bg-neutral-700 flex items-center justify-center transition group relative" title="ビビッド">
                    <i class="ph ph-sparkle text-yellow-400"></i>
                </button>
                 <button onclick="applyPreset('bw')" class="w-10 h-10 rounded-lg bg-neutral-800 hover:bg-neutral-700 flex items-center justify-center transition group relative" title="モノクロ">
                    <span class="font-serif font-bold text-xs">BW</span>
                </button>

                <div class="w-8 h-px bg-neutral-800 shrink-0 my-1"></div>
                <span class="text-[9px] font-bold text-neutral-500 tracking-widest">MY STYLE</span>
                
                <div id="my-style-list" class="flex flex-col gap-2 w-full px-1 items-center">
                    <!-- マイスタイルがここに追加される -->
                </div>

                <!-- 保存ボタン (ID付与) -->
                <button id="btn-save-style" class="w-8 h-8 rounded-full bg-neutral-800 hover:bg-neutral-700 text-neutral-400 flex items-center justify-center transition" title="現在の設定を保存">
                    <i class="ph ph-plus"></i>
                </button>

            </div>

            <!-- Magic Style パネル (Mode B) -->
            <div id="ai-panel" class="flex-col w-full px-4 gap-4 pb-4 sidebar-content hidden-content hidden overflow-y-auto">
                
                <div class="flex justify-between items-center mb-2 pb-2 border-b border-neutral-700">
                    <h4 class="text-xs font-bold text-neutral-400 tracking-wider">Magic Style</h4>
                     <button onclick="toggleAIMode()" class="text-neutral-500 hover:text-white" title="閉じる">
                        <i class="ph ph-x text-lg"></i>
                    </button>
                </div>

                <p class="text-xs text-neutral-500 mb-2 leading-tight">キーワードを選んでスタイル作成</p>

                <!-- TONE -->
                <div class="mb-1">
                    <h4 class="text-[10px] font-bold text-neutral-500 tracking-widest mb-2 category-header" ondblclick="resetCategory('light')" title="ダブルクリックでこのカテゴリをリセット">TONE</h4>
                    <div id="ai-tags-tone" class="flex flex-wrap gap-2"></div>
                </div>

                <!-- COLOR -->
                <div class="mb-1">
                    <h4 class="text-[10px] font-bold text-neutral-500 tracking-widest mb-2 category-header" ondblclick="resetCategory('color')" title="ダブルクリックでこのカテゴリをリセット">COLOR</h4>
                    <div id="ai-tags-color" class="flex flex-wrap gap-2"></div>
                </div>

                <!-- MOOD -->
                <div class="mb-1">
                    <h4 class="text-[10px] font-bold text-neutral-500 tracking-widest mb-2 category-header" ondblclick="resetCategory('style')" title="ダブルクリックでこのカテゴリをリセット">MOOD</h4>
                    <div id="ai-tags-mood" class="flex flex-wrap gap-2"></div>
                </div>

                <!-- 強度スライダー -->
                <div class="bg-neutral-800/80 p-3 rounded-lg border border-neutral-700 mt-2">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-xs font-bold text-neutral-400">アレンジ強度</span>
                        <span id="ai-strength-val" class="text-xs font-mono text-purple-400">1.00x</span>
                    </div>
                    <input type="range" id="ai-strength" min="0.1" max="2.0" step="0.05" value="1.0" class="w-full h-1 bg-neutral-600 rounded-lg appearance-none cursor-pointer mb-1 accent-purple-500">
                </div>
            </div>

        </aside>

        <!-- キャンバスエリア -->
        <main class="flex-1 bg-neutral-950 relative overflow-hidden canvas-container flex items-center justify-center" id="drop-zone">
            <!-- 初期メッセージ -->
            <div id="placeholder-msg" class="text-center pointer-events-none absolute inset-0 flex flex-col items-center justify-center z-10">
                <i class="ph ph-image text-6xl text-neutral-600 mb-4"></i>
                <p class="text-neutral-300 font-medium tracking-wide">ここに画像をドロップ<br>または「開く」を選択</p>
            </div>
            
            <!-- キャンバスラッパー -->
            <div id="canvas-wrapper" class="absolute w-full h-full flex items-center justify-center pointer-events-none">
                <canvas id="editor-canvas" class="hidden pointer-events-auto cursor-grab"></canvas>
            </div>

            <!-- アクションバー -->
            <div id="action-bar" class="absolute bottom-8 left-1/2 transform -translate-x-1/2 bg-neutral-800 px-4 py-2 rounded-full shadow-xl flex items-center gap-3 border border-neutral-700 hidden z-30">
                <span id="action-label" class="text-xs font-medium text-neutral-300 mr-2">範囲選択中</span>
                <button onclick="applyCurrentAction()" class="bg-blue-600 hover:bg-blue-500 text-white text-xs px-3 py-1.5 rounded-full font-medium transition flex items-center gap-1">
                    <i class="ph ph-check"></i> 適用
                </button>
                <button onclick="cancelAction()" class="bg-neutral-700 hover:bg-neutral-600 text-neutral-300 text-xs px-3 py-1.5 rounded-full font-medium transition flex items-center gap-1">
                    <i class="ph ph-x"></i> キャンセル
                </button>
            </div>

            <!-- 比較ボタン（左下） -->
            <button id="compare-btn" class="absolute bottom-6 left-6 z-40 bg-neutral-800/90 backdrop-blur text-neutral-300 px-4 py-2 rounded-full text-xs font-bold border border-neutral-700 shadow-lg select-none transition flex items-center gap-2 hidden group hover:bg-neutral-700" title="長押しで比較">
                <i class="ph ph-arrows-left-right text-lg"></i>
                <span>比較</span>
            </button>

            <!-- ズームインジケーター -->
            <div id="zoom-indicator" class="absolute bottom-6 right-6 bg-black/70 text-white text-xs px-2 py-1 rounded opacity-0 transition-opacity pointer-events-none font-mono z-20">
                100%
            </div>
            
            <!-- ロード中 -->
            <div id="loading" class="absolute inset-0 bg-neutral-950/80 hidden items-center justify-center z-[70]">
                <i class="ph ph-spinner animate-spin text-3xl text-neutral-400"></i>
            </div>
        </main>

        <!-- 右サイドバー -->
        <aside class="w-80 bg-neutral-900 border-l border-neutral-800 flex flex-col shrink-0 overflow-y-auto z-10 custom-scroll">
            <!-- パネル群 -->
            <div id="panel-local" class="px-6 py-5 border-b border-neutral-800 bg-neutral-900/50 relative">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xs font-bold tracking-widest text-blue-400 uppercase flex items-center gap-2">
                        <i class="ph ph-selection-plus"></i> Local Adjustments
                    </h2>
                    <span class="text-[10px] text-neutral-500 bg-neutral-800 px-2 py-0.5 rounded">選択範囲のみ</span>
                </div>
                <div id="local-disabled-overlay" class="absolute inset-0 bg-neutral-900/80 z-20 flex items-center justify-center backdrop-blur-[1px] transition-opacity duration-300">
                    <p class="text-xs text-neutral-400 text-center px-4">
                        <i class="ph ph-cursor-click mb-1 block text-lg"></i>
                        範囲選択ツールまたは<br>トリミングツールを使用してください
                    </p>
                </div>
                <div class="mb-5 flex items-center justify-between">
                    <label for="invert-mask" class="text-xs text-neutral-400 cursor-pointer select-none">選択範囲を反転 (外側に適用)</label>
                    <input type="checkbox" id="invert-mask" class="custom-checkbox" onchange="requestAnimationFrame(() => render())">
                </div>
                
                <!-- モザイク (上に移動) -->
                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition param-label" title="ダブルクリックでリセット">モザイク</span>
                        <input type="number" id="num-localMosaic" value="0" min="0" max="100">
                    </div>
                    <input type="range" id="localMosaic" min="0" max="100" value="0" step="1" class="control-slider">
                </div>

                <!-- ぼかし -->
                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition param-label" title="ダブルクリックでリセット">ぼかし</span>
                        <input type="number" id="num-localBlur" value="0" min="0" max="50" step="1">
                    </div>
                    <input type="range" id="localBlur" min="0" max="50" value="0" step="1" class="control-slider">
                </div>
                
                <!-- 境界のぼかし (モザイク/ぼかしの下、Max 200, ID: localFeather) -->
                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition param-label" title="ダブルクリックでリセット">境界のぼかし (Feather)</span>
                        <input type="number" id="num-localFeather" value="0" min="0" max="200" step="1">
                    </div>
                    <input type="range" id="localFeather" min="0" max="200" value="0" step="1" class="control-slider">
                </div>
            </div>

            <!-- Global Light & Color -->
            <div class="px-6 py-5 border-b border-neutral-800">
                <h2 class="text-xs font-bold tracking-widest text-neutral-500 uppercase mb-4">Global Light & Color</h2>
                
                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition param-label" title="ダブルクリックでリセット">露光量</span>
                        <input type="number" id="num-brightness" value="0" min="-100" max="100">
                    </div>
                    <input type="range" id="brightness" min="-100" max="100" value="0" class="control-slider">
                </div>
                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition param-label" title="ダブルクリックでリセット">コントラスト</span>
                        <input type="number" id="num-contrast" value="0" min="-100" max="100">
                    </div>
                    <input type="range" id="contrast" min="-100" max="100" value="0" class="control-slider">
                </div>
                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition param-label" title="ダブルクリックでリセット">ハイライト</span>
                        <input type="number" id="num-highlights" value="0" min="-100" max="100">
                    </div>
                    <input type="range" id="highlights" min="-100" max="100" value="0" class="control-slider">
                </div>
                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition param-label" title="ダブルクリックでリセット">シャドウ</span>
                        <input type="number" id="num-shadows" value="0" min="-100" max="100">
                    </div>
                    <input type="range" id="shadows" min="-100" max="100" value="0" class="control-slider">
                </div>
                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition param-label" title="ダブルクリックでリセット">彩度</span>
                        <input type="number" id="num-saturation" value="0" min="-100" max="100">
                    </div>
                    <input type="range" id="saturation" min="-100" max="100" value="0" class="control-slider">
                </div>
                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition text-blue-300 param-label" title="ダブルクリックでリセット">自然な彩度</span>
                        <input type="number" id="num-vibrance" value="0" min="-100" max="100">
                    </div>
                    <input type="range" id="vibrance" min="-100" max="100" value="0" class="control-slider">
                </div>
                 <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition param-label" title="ダブルクリックでリセット">色温度</span>
                        <input type="number" id="num-temperature" value="0" min="-50" max="50">
                    </div>
                    <div class="relative h-1 w-full rounded-full bg-gradient-to-r from-orange-900 via-neutral-600 to-blue-900 mb-2 top-3 pointer-events-none"></div>
                    <input type="range" id="temperature" min="-50" max="50" value="0" class="control-slider relative z-10">
                </div>
            </div>

            <div class="px-6 py-5">
                <h2 class="text-xs font-bold tracking-widest text-neutral-500 uppercase mb-4">Creative & Effects</h2>
                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition param-label" title="ダブルクリックでリセット">色相</span>
                        <input type="number" id="num-hue" value="0" min="-180" max="180">
                    </div>
                    <div class="relative h-1 w-full rounded-full bg-gradient-to-r from-red-500 via-green-500 to-blue-500 mb-2 top-3 pointer-events-none opacity-50"></div>
                    <input type="range" id="hue" min="-180" max="180" value="0" class="control-slider relative z-10">
                </div>
                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition param-label" title="ダブルクリックでリセット">セピア</span>
                        <input type="number" id="num-sepia" value="0" min="0" max="100">
                    </div>
                    <input type="range" id="sepia" min="0" max="100" value="0" class="control-slider">
                </div>
                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition param-label" title="ダブルクリックでリセット">反転</span>
                        <input type="number" id="num-invert" value="0" min="0" max="100">
                    </div>
                    <input type="range" id="invert" min="0" max="100" value="0" class="control-slider">
                </div>
                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition param-label" title="ダブルクリックでリセット">全体ぼかし</span>
                        <input type="number" id="num-blur" value="0" min="0" max="20" step="0.5">
                    </div>
                    <input type="range" id="blur" min="0" max="20" value="0" step="0.5" class="control-slider">
                </div>
                <div class="w-full h-px bg-neutral-800 my-4"></div>
                <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition param-label" title="ダブルクリックでリセット">粒子</span>
                        <input type="number" id="num-grain" value="0" min="0" max="100">
                    </div>
                    <input type="range" id="grain" min="0" max="100" value="0" class="control-slider">
                </div>
                 <div class="mb-5 group">
                    <div class="flex justify-between items-center text-xs mb-2">
                        <span class="text-neutral-400 group-hover:text-neutral-200 transition param-label" title="ダブルクリックでリセット">周辺減光</span>
                        <input type="number" id="num-vignette" value="0" min="0" max="100">
                    </div>
                    <input type="range" id="vignette" min="0" max="100" value="0" class="control-slider">
                </div>
            </div>

            <!-- フッター -->
            <div class="mt-auto p-6 text-center shrink-0">
                <p class="text-[10px] text-neutral-500 font-medium">M3-PhotoEditor Ver.2.13</p>
                <p class="text-[10px] text-neutral-600 mt-1 tracking-wider">created by Hayao</p>
            </div>
        </aside>
    </div>

    <script>
        // --- 状態管理クラス ---
        class HistoryManager {
            constructor() {
                this.undoStack = []; this.redoStack = []; this.limit = 25;
            }
            push(state) {
                const safeState = {
                    imageData: state.imageData, 
                    cleanImageData: state.cleanImageData,
                    globalParams: JSON.parse(JSON.stringify(state.globalParams))
                };
                this.undoStack.push(safeState);
                if (this.undoStack.length > this.limit) this.undoStack.shift();
                this.redoStack = []; 
                this.updateButtons();
            }
            undo() {
                if (this.undoStack.length <= 1) return null;
                const current = this.undoStack.pop(); 
                this.redoStack.push(current);
                this.updateButtons(); 
                return this.undoStack[this.undoStack.length - 1];
            }
            redo() {
                if (this.redoStack.length === 0) return null;
                const next = this.redoStack.pop(); 
                this.undoStack.push(next);
                this.updateButtons(); 
                return next;
            }
            updateButtons() {
                const uBtn = document.getElementById('btn-undo');
                const rBtn = document.getElementById('btn-redo');
                if (uBtn) uBtn.disabled = this.undoStack.length <= 1;
                if (rBtn) rBtn.disabled = this.redoStack.length === 0;
            }
            reset() { this.undoStack = []; this.redoStack = []; this.updateButtons(); }
        }

        // --- メインロジック ---
        const canvas = document.getElementById('editor-canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const uploadInput = document.getElementById('upload-input');
        const downloadBtn = document.getElementById('download-btn');
        const placeholderMsg = document.getElementById('placeholder-msg');
        const loadingOverlay = document.getElementById('loading');
        const dropZone = document.getElementById('drop-zone');
        const invertCheckbox = document.getElementById('invert-mask');
        const cropOptions = document.getElementById('crop-options');
        const aspectRatioSelect = document.getElementById('aspect-ratio-select');
        const compareBtn = document.getElementById('compare-btn');
        
        const toolBtns = {
            hand: document.getElementById('tool-hand'),
            select: document.getElementById('tool-select'),
            circle: document.getElementById('tool-circle'),
            crop: document.getElementById('tool-crop')
        };
        const actionBar = document.getElementById('action-bar');
        const actionLabel = document.getElementById('action-label');
        const localPanelOverlay = document.getElementById('local-disabled-overlay');

        // AI Panel Elements
        const leftSidebar = document.getElementById('left-sidebar');
        const sidebarPresets = document.getElementById('sidebar-presets');
        const aiPanel = document.getElementById('ai-panel');
        const aiStrengthSlider = document.getElementById('ai-strength');
        const aiStrengthVal = document.getElementById('ai-strength-val');
        const btnMagicStyle = document.getElementById('btn-magic-style');
        const myStyleList = document.getElementById('my-style-list');
        const btnSaveStyle = document.getElementById('btn-save-style');

        const history = new HistoryManager();
        let isImageLoaded = false;
        let currentMode = 'hand'; 
        let currentFileName = 'photo_edited';
        
        let baseImage = null; 
        let initialCleanImage = null; 
        
        // メモリ内スタイル保存（LocalStorage使えない場合のフォールバック）
        let memoryStyles = [];
        
        let viewState = { scale: 1, x: 0, y: 0, isDragging: false, lastX: 0, lastY: 0 };
        let selectionState = { active: false, dragMode: null, startX: 0, startY: 0, initialRect: null, initialRotation: 0, anchorGlobal: null, shape: 'rect', rotation: 0, rect: { x: 0, y: 0, w: 0, h: 0 } };

        const globalParams = { 
            brightness: 0, contrast: 0, saturation: 0, vibrance: 0, temperature: 0, 
            hue: 0, sepia: 0, invert: 0, blur: 0, grain: 0, vignette: 0, highlights: 0, shadows: 0 
        };
        const localParams = { blur: 0, mosaic: 0, feather: 0 }; 

        function updateCanvasTransform() {
            canvas.style.transform = `translate(${viewState.x}px, ${viewState.y}px) scale(${viewState.scale})`;
            const indicator = document.getElementById('zoom-indicator');
            indicator.textContent = Math.round(viewState.scale * 100) + '%';
            indicator.style.opacity = '1';
            clearTimeout(window.zoomTimer);
            window.zoomTimer = setTimeout(() => indicator.style.opacity = '0', 1500);
        }

        window.resetView = () => {
            if(!isImageLoaded || !baseImage) return;
            const containerW = dropZone.clientWidth; const containerH = dropZone.clientHeight;
            const scaleW = (containerW - 40) / canvas.width; const scaleH = (containerH - 40) / canvas.height;
            viewState.scale = Math.min(scaleW, scaleH, 1); viewState.x = 0; viewState.y = 0;
            updateCanvasTransform();
        };

        function setMode(mode) {
            currentMode = mode;
            Object.keys(toolBtns).forEach(k => toolBtns[k].classList.toggle('active', k === mode));
            if (mode === 'hand') { canvas.style.cursor = 'grab'; canvasWrapper.style.cursor = 'grab'; cancelAction(); } 
            else { canvas.style.cursor = 'crosshair'; canvasWrapper.style.cursor = 'crosshair'; }
            if (mode === 'select' || mode === 'circle') { localPanelOverlay.classList.add('opacity-0', 'pointer-events-none'); cropOptions.classList.add('hidden'); } 
            else { localPanelOverlay.classList.remove('opacity-0', 'pointer-events-none'); }
            if (mode === 'crop') { cancelAction(); localPanelOverlay.classList.remove('opacity-0', 'pointer-events-none'); localPanelOverlay.querySelector('p').innerHTML = '<i class="ph ph-crop mb-1 block text-lg"></i>トリミング範囲を選択して<br>「適用」を押してください'; cropOptions.classList.remove('hidden'); } 
            else if (mode !== 'select' && mode !== 'circle') { localPanelOverlay.querySelector('p').innerHTML = '<i class="ph ph-cursor-click mb-1 block text-lg"></i>範囲選択ツールまたは<br>トリミングツールを使用してください'; cropOptions.classList.add('hidden'); }
        }
        
        toolBtns.hand.addEventListener('click', () => setMode('hand'));
        toolBtns.select.addEventListener('click', () => setMode('select'));
        toolBtns.circle.addEventListener('click', () => setMode('circle'));
        toolBtns.crop.addEventListener('click', () => setMode('crop'));

        function setupParamListeners(paramsObj, prefix) {
            Object.keys(paramsObj).forEach(key => {
                const id = prefix ? prefix + key.charAt(0).toUpperCase() + key.slice(1) : key;
                const slider = document.getElementById(id); const numInput = document.getElementById('num-' + id);
                if (slider && numInput) {
                    slider.addEventListener('input', (e) => {
                        paramsObj[key] = parseFloat(e.target.value); numInput.value = e.target.value;
                        requestAnimationFrame(() => render());
                    });
                    if (!prefix) slider.addEventListener('change', () => { if (isImageLoaded) saveHistoryState(); });
                    numInput.addEventListener('input', (e) => {
                        let val = parseFloat(e.target.value); if (isNaN(val)) return;
                        paramsObj[key] = val; slider.value = val;
                        requestAnimationFrame(() => render());
                    });
                    if (!prefix) numInput.addEventListener('change', () => { if (isImageLoaded) saveHistoryState(); });
                    
                    const label = slider.parentElement.querySelector('.param-label');
                    if (label) {
                        label.addEventListener('dblclick', () => {
                            paramsObj[key] = 0; slider.value = 0; numInput.value = 0;
                            if (isImageLoaded) saveHistoryState();
                            render();
                        });
                    }
                }
            });
        }
        setupParamListeners(globalParams, '');
        setupParamListeners(localParams, 'local');

        function loadFile(file) {
            if (!file || !file.type.startsWith('image/')) return;
            currentFileName = file.name.replace(/\.[^/.]+$/, "");
            loadingOverlay.classList.remove('hidden'); loadingOverlay.classList.add('flex');
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = async () => {
                    baseImage = await createImageBitmap(img);
                    initialCleanImage = await createImageBitmap(img);
                    canvas.width = baseImage.width; canvas.height = baseImage.height;
                    isImageLoaded = true; placeholderMsg.style.display = 'none'; canvas.classList.remove('hidden'); downloadBtn.disabled = false;
                    compareBtn.classList.remove('hidden'); 
                    
                    history.reset(); 
                    resetParams(globalParams); 
                    resetParams(localParams);
                    selectedTags = []; 
                    cancelAction();
                    setMode('hand');
                    
                    if (!document.getElementById('ai-panel').classList.contains('hidden-content')) {
                        closeAIModal(false);
                    }

                    saveHistoryState();
                    resetView(); 
                    updateInputDisplays(globalParams, ''); 
                    updateInputDisplays(localParams, 'local');
                    loadingOverlay.classList.add('hidden'); loadingOverlay.classList.remove('flex');
                    render();
                    loadMyStyles();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        async function saveHistoryState() {
            if (!isImageLoaded) return;
            const tmpCanvas = document.createElement('canvas'); tmpCanvas.width = baseImage.width; tmpCanvas.height = baseImage.height;
            const tmpCtx = tmpCanvas.getContext('2d'); tmpCtx.drawImage(baseImage, 0, 0);
            const imageData = tmpCtx.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height);
            
            const cleanTmpCanvas = document.createElement('canvas'); cleanTmpCanvas.width = initialCleanImage.width; cleanTmpCanvas.height = initialCleanImage.height;
            const cleanTmpCtx = cleanTmpCanvas.getContext('2d'); cleanTmpCtx.drawImage(initialCleanImage, 0, 0);
            const cleanImageData = cleanTmpCtx.getImageData(0, 0, cleanTmpCanvas.width, cleanTmpCanvas.height);

            history.push({ imageData: imageData, cleanImageData: cleanImageData, globalParams: JSON.parse(JSON.stringify(globalParams)) });
        }

        async function restoreState(state) {
            if (!state) return;
            baseImage = await createImageBitmap(state.imageData);
            initialCleanImage = await createImageBitmap(state.cleanImageData);
            canvas.width = baseImage.width; canvas.height = baseImage.height;
            Object.assign(globalParams, JSON.parse(JSON.stringify(state.globalParams)));
            updateInputDisplays(globalParams, ''); resetParams(localParams); cancelAction(); render();
        }

        window.undo = async () => { const state = history.undo(); if (state) await restoreState(state); };
        window.redo = async () => { const state = history.redo(); if (state) await restoreState(state); };

        window.applyCurrentAction = async () => {
            if (!selectionState.active) return;
            loadingOverlay.classList.remove('hidden'); loadingOverlay.classList.add('flex');
            setTimeout(async () => {
                if (currentMode === 'select' || currentMode === 'circle') await applyLocalEffect();
                else if (currentMode === 'crop') await applyCrop();
                loadingOverlay.classList.add('hidden'); loadingOverlay.classList.remove('flex');
                const flash = document.createElement('div');
                flash.className = 'absolute inset-0 bg-white pointer-events-none flash-overlay z-50';
                document.body.appendChild(flash); setTimeout(() => flash.remove(), 500);
            }, 10);
        };

        window.cancelAction = () => {
            selectionState.active = false; selectionState.rect = { x: 0, y: 0, w: 0, h: 0 }; selectionState.rotation = 0;
            actionBar.classList.add('hidden'); resetParams(localParams); invertCheckbox.checked = false; render();
        };

        async function applyLocalEffect() {
            const tmpCanvas = document.createElement('canvas'); tmpCanvas.width = baseImage.width; tmpCanvas.height = baseImage.height;
            const tmpCtx = tmpCanvas.getContext('2d');
            const w = tmpCanvas.width; const h = tmpCanvas.height;
            const rect = selectionState.rect; const params = localParams;
            const rot = selectionState.rotation; const cx = rect.x + rect.w / 2; const cy = rect.y + rect.h / 2;

            if (params.mosaic > 0 || params.blur > 0) {
                // マスクを作成
                const maskCanvas = document.createElement('canvas');
                maskCanvas.width = w;
                maskCanvas.height = h;
                const maskCtx = maskCanvas.getContext('2d');

                maskCtx.save();
                maskCtx.translate(cx, cy);
                maskCtx.rotate(rot);
                maskCtx.translate(-cx, -cy);
                maskCtx.beginPath();
                if (selectionState.shape === 'circle') {
                     maskCtx.ellipse(cx, cy, Math.abs(rect.w/2), Math.abs(rect.h/2), 0, 0, 2*Math.PI);
                } else {
                     maskCtx.rect(rect.x, rect.y, rect.w, rect.h);
                }
                maskCtx.fillStyle = 'white';
                // フェザー適用
                if (params.feather > 0) {
                    maskCtx.filter = `blur(${params.feather}px)`;
                }
                maskCtx.fill();
                maskCtx.restore();

                // エフェクト画像作成
                const effectCanvas = document.createElement('canvas');
                effectCanvas.width = w;
                effectCanvas.height = h;
                const effectCtx = effectCanvas.getContext('2d');
                effectCtx.drawImage(baseImage, 0, 0);

                if (params.blur > 0) {
                    const bC = document.createElement('canvas'); bC.width = w; bC.height = h;
                    const bCtx = bC.getContext('2d'); bCtx.filter = `blur(${params.blur}px)`;
                    bCtx.drawImage(effectCanvas, 0, 0); effectCtx.clearRect(0,0,w,h); effectCtx.drawImage(bC, 0, 0);
                }
                if (params.mosaic > 0) {
                    const sF = Math.max(0.005, 1 - (params.mosaic / 105)); 
                    const offC = document.createElement('canvas'); offC.width = Math.max(1, w * sF); offC.height = Math.max(1, h * sF);
                    const offCtx = offC.getContext('2d'); offCtx.drawImage(effectCanvas, 0, 0, offC.width, offC.height);
                    effectCtx.imageSmoothingEnabled = false; effectCtx.drawImage(offC, 0, 0, offC.width, offC.height, 0, 0, w, h); effectCtx.imageSmoothingEnabled = true;
                }

                // 合成 (背景: エフェクト画像 or 元画像)
                if (invertCheckbox.checked) {
                    // 反転: 背景=エフェクト、選択範囲=元
                    tmpCtx.drawImage(effectCanvas, 0, 0);
                    
                    // マスクで元画像を切り抜いて重ねる (destination-in でマスク部分だけ残す)
                    const maskedOriginal = document.createElement('canvas'); maskedOriginal.width = w; maskedOriginal.height = h;
                    const moCtx = maskedOriginal.getContext('2d');
                    moCtx.drawImage(baseImage, 0, 0);
                    moCtx.globalCompositeOperation = 'destination-in';
                    moCtx.drawImage(maskCanvas, 0, 0);
                    
                    tmpCtx.drawImage(maskedOriginal, 0, 0);

                } else {
                    // 通常: 背景=元、選択範囲=エフェクト
                    tmpCtx.drawImage(baseImage, 0, 0);
                    
                    const maskedEffect = document.createElement('canvas'); maskedEffect.width = w; maskedEffect.height = h;
                    const meCtx = maskedEffect.getContext('2d');
                    meCtx.drawImage(effectCanvas, 0, 0);
                    meCtx.globalCompositeOperation = 'destination-in';
                    meCtx.drawImage(maskCanvas, 0, 0);

                    tmpCtx.drawImage(maskedEffect, 0, 0);
                }
            }
            baseImage = await createImageBitmap(tmpCanvas);
            await saveHistoryState(); cancelAction();
        }

        async function applyCrop() {
            const rect = selectionState.rect; const rotation = selectionState.rotation;
            if (rect.w < 1 || rect.h < 1) return;
            const cx = rect.x + rect.w / 2; const cy = rect.y + rect.h / 2;
            const w = Math.abs(rect.w); const h = Math.abs(rect.h);
            const cropCanvas = document.createElement('canvas'); cropCanvas.width = w; cropCanvas.height = h;
            const cCtx = cropCanvas.getContext('2d');
            cCtx.translate(w / 2, h / 2); cCtx.rotate(-rotation); cCtx.drawImage(baseImage, -cx, -cy);
            baseImage = await createImageBitmap(cropCanvas);
            
            const cleanCropCanvas = document.createElement('canvas'); cleanCropCanvas.width = w; cleanCropCanvas.height = h;
            const ccCtx = cleanCropCanvas.getContext('2d');
            ccCtx.translate(w / 2, h / 2); ccCtx.rotate(-rotation); ccCtx.drawImage(initialCleanImage, -cx, -cy);
            initialCleanImage = await createImageBitmap(cleanCropCanvas);

            canvas.width = w; canvas.height = h;
            await saveHistoryState(); cancelAction(); resetView();
        }

        function applyPixelManipulations(targetCtx, highlights, shadows, vibrance, temperature) {
            if (highlights === 0 && shadows === 0 && vibrance === 0 && temperature === 0) return;
            const imgData = targetCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data; const len = data.length;
            const vFactor = vibrance / 100;

            for (let i = 0; i < len; i += 4) {
                let r = data[i], g = data[i+1], b = data[i+2];
                if (temperature !== 0) { r -= temperature * 1.5; b += temperature * 1.5; }
                if (highlights !== 0 || shadows !== 0) {
                    let nR = r / 255, nG = g / 255, nB = b / 255;
                    const lum = Math.max(0, Math.min(1, 0.2126 * nR + 0.7152 * nG + 0.0722 * nB));
                    if (shadows !== 0) {
                        const sMask = (1 - lum) * (1 - lum); const sFactor = (shadows / 100) * 0.8;
                        if (shadows > 0) { const lift = sFactor * sMask; nR += (1 - nR) * lift; nG += (1 - nG) * lift; nB += (1 - nB) * lift; }
                        else { const darken = 1 - ((-sFactor) * sMask * 0.8); nR *= darken; nG *= darken; nB *= darken; }
                    }
                    if (highlights !== 0) {
                        const hMask = lum * lum; const hFactor = (highlights / 100) * 0.8;
                        if (highlights > 0) { const lift = hFactor * hMask; nR += (1 - nR) * lift; nG += (1 - nG) * lift; nB += (1 - nB) * lift; }
                        else { const darken = 1 - ((-hFactor) * hMask * 0.8); nR *= darken; nG *= darken; nB *= darken; }
                    }
                    r = nR * 255; g = nG * 255; b = nB * 255;
                }
                if (vibrance !== 0) {
                    const max = Math.max(r, g, b), avg = (r + g + b) / 3, sat = max - avg;
                    if (sat < 255) {
                        let amt = vFactor * (1 - Math.pow(Math.max(0, sat/255), 0.5));
                        r += (r - avg) * amt * 2.0; g += (g - avg) * amt * 2.0; b += (b - avg) * amt * 2.0;
                    }
                }
                const noise = (Math.random() - 0.5) * 0.8;
                data[i] = Math.min(255, Math.max(0, r + noise));
                data[i+1] = Math.min(255, Math.max(0, g + noise));
                data[i+2] = Math.min(255, Math.max(0, b + noise));
            }
            targetCtx.putImageData(imgData, 0, 0);
        }

        function render(isExport = false, isCompare = false) {
            if (!isImageLoaded || !baseImage) return;
            const w = canvas.width; const h = canvas.height; const gp = globalParams;
            
            ctx.filter = 'none';
            ctx.setTransform(1, 0, 0, 1, 0, 0);

            if (isCompare) {
                ctx.save();
                ctx.clearRect(0, 0, w, h);
                ctx.drawImage(initialCleanImage, 0, 0); 
                ctx.restore();
                return;
            }

            ctx.clearRect(0, 0, w, h);
            let f = `brightness(${100 + gp.brightness}%) contrast(${100 + gp.contrast}%) saturate(${100 + gp.saturation}%)`;
            if (gp.hue !== 0) f += ` hue-rotate(${gp.hue}deg)`;
            if (gp.sepia !== 0) f += ` sepia(${gp.sepia}%)`;
            if (gp.invert !== 0) f += ` invert(${gp.invert}%)`;
            if (gp.blur !== 0) f += ` blur(${gp.blur}px)`;

            ctx.save();
            ctx.filter = f;
            ctx.drawImage(baseImage, 0, 0); 
            ctx.filter = 'none';

            if (gp.highlights !== 0 || gp.shadows !== 0 || gp.vibrance !== 0 || gp.temperature !== 0) {
                applyPixelManipulations(ctx, gp.highlights, gp.shadows, gp.vibrance, gp.temperature);
            }

            if (selectionState.active && (currentMode === 'select' || currentMode === 'circle')) {
                const lp = localParams; const rect = selectionState.rect;
                const rot = selectionState.rotation; const cx = rect.x + rect.w/2; const cy = rect.y + rect.h/2;
                if (lp.mosaic > 0 || lp.blur > 0) {
                    const originalCanvas = document.createElement('canvas'); originalCanvas.width = w; originalCanvas.height = h;
                    const originalCtx = originalCanvas.getContext('2d'); originalCtx.drawImage(canvas, 0, 0);

                    // マスク (プレビュー)
                    const maskCanvas = document.createElement('canvas'); maskCanvas.width = w; maskCanvas.height = h;
                    const maskCtx = maskCanvas.getContext('2d');
                    maskCtx.save();
                    maskCtx.translate(cx, cy); maskCtx.rotate(rot); maskCtx.translate(-cx, -cy);
                    maskCtx.beginPath();
                    if (selectionState.shape === 'circle') maskCtx.ellipse(cx, cy, Math.abs(rect.w/2), Math.abs(rect.h/2), 0, 0, 2*Math.PI);
                    else maskCtx.rect(rect.x, rect.y, rect.w, rect.h);
                    maskCtx.fillStyle = 'white';
                    if (lp.feather > 0) maskCtx.filter = `blur(${lp.feather}px)`;
                    maskCtx.fill();
                    maskCtx.restore();

                    // エフェクト
                    const eC = document.createElement('canvas'); eC.width = w; eC.height = h;
                    const eCtx = eC.getContext('2d'); eCtx.drawImage(originalCanvas, 0, 0); 
                    if (lp.blur > 0) {
                        const bC = document.createElement('canvas'); bC.width = w; bC.height = h;
                        const bCtx = bC.getContext('2d'); bCtx.filter = `blur(${lp.blur}px)`; bCtx.drawImage(eC,0,0); eCtx.clearRect(0,0,w,h); eCtx.drawImage(bC,0,0);
                    }
                    if (lp.mosaic > 0) {
                        const sF = Math.max(0.005, 1-(lp.mosaic/105)); const offC = document.createElement('canvas'); offC.width=Math.max(1,w*sF); offC.height=Math.max(1,h*sF);
                        const offCtx = offC.getContext('2d'); offCtx.drawImage(eCtx.canvas,0,0,offC.width,offC.height); eCtx.imageSmoothingEnabled=false; eCtx.drawImage(offC,0,0,offC.width,offC.height,0,0,w,h); eCtx.imageSmoothingEnabled=true;
                    }

                    // 合成
                    ctx.save();
                    const maskedEffect = document.createElement('canvas'); maskedEffect.width = w; maskedEffect.height = h;
                    const meCtx = maskedEffect.getContext('2d');
                    
                    if (invertCheckbox.checked) {
                         const iMask = document.createElement('canvas'); iMask.width = w; iMask.height = h;
                         const iCtx = iMask.getContext('2d');
                         iCtx.fillStyle = 'white'; iCtx.fillRect(0,0,w,h);
                         iCtx.globalCompositeOperation = 'destination-out';
                         iCtx.drawImage(maskCanvas, 0, 0);

                         meCtx.drawImage(eC, 0, 0);
                         meCtx.globalCompositeOperation = 'destination-in';
                         meCtx.drawImage(iMask, 0, 0);
                    } else {
                         meCtx.drawImage(eC, 0, 0);
                         meCtx.globalCompositeOperation = 'destination-in';
                         meCtx.drawImage(maskCanvas, 0, 0);
                    }
                    ctx.drawImage(maskedEffect, 0, 0);
                    ctx.restore();
                }
            }

            if (gp.grain > 0) drawGrain(ctx, w, h, gp.grain);
            if (gp.vignette > 0) {
                ctx.save(); ctx.globalCompositeOperation = 'multiply'; const r = Math.max(w, h)/1.5;
                const grad = ctx.createRadialGradient(w/2, h/2, r * 0.4, w/2, h/2, r);
                grad.addColorStop(0, 'rgba(0,0,0,0)'); grad.addColorStop(1, `rgba(0,0,0,${gp.vignette/100})`);
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h); ctx.restore();
            }
            ctx.restore();

            if (!isExport && selectionState.active) {
                const r = selectionState.rect; const rot = selectionState.rotation; const cx = r.x+r.w/2, cy = r.y+r.h/2;
                ctx.save(); ctx.translate(cx, cy); ctx.rotate(rot); ctx.translate(-cx, -cy);
                ctx.strokeStyle = currentMode === 'crop' ? '#fff' : 'white';
                ctx.lineWidth = 1.5 / viewState.scale; ctx.setLineDash([5/viewState.scale, 5/viewState.scale]);
                if (selectionState.shape === 'circle' && currentMode !== 'crop') { ctx.beginPath(); ctx.ellipse(cx, cy, Math.abs(r.w/2), Math.abs(r.h/2), 0, 0, 2*Math.PI); ctx.stroke(); }
                else ctx.strokeRect(r.x, r.y, r.w, r.h);
                ctx.setLineDash([]); drawHandles(ctx, r); ctx.restore();
            }
        }

        function drawHandles(tCtx, r) {
            const hs = 8 / viewState.scale; tCtx.fillStyle = 'white'; tCtx.strokeStyle = 'black'; tCtx.lineWidth = 1 / viewState.scale;
            const hnds = [{x:r.x,y:r.y}, {x:r.x+r.w,y:r.y}, {x:r.x+r.w,y:r.y+r.h}, {x:r.x,y:r.y+r.h}];
            hnds.forEach(h => { tCtx.fillRect(h.x-hs/2, h.y-hs/2, hs, hs); tCtx.strokeRect(h.x-hs/2, h.y-hs/2, hs, hs); });
            const cx = r.x + r.w / 2, ry = r.y - 25 / viewState.scale;
            tCtx.beginPath(); tCtx.moveTo(cx, r.y); tCtx.lineTo(cx, ry); tCtx.stroke();
            tCtx.beginPath(); tCtx.arc(cx, ry, 5 / viewState.scale, 0, 2 * Math.PI); tCtx.fill(); tCtx.stroke();
        }

        function drawGrain(tCtx, w, h, s) {
            const gC = document.createElement('canvas'); gC.width = 256; gC.height = 256;
            const gCtx = gC.getContext('2d'); const iD = gCtx.createImageData(256, 256); const d = iD.data;
            for (let i = 0; i < d.length; i += 4) { const v = (Math.random()-0.5)*(s/100)*128; d[i]=128+v; d[i+1]=128+v; d[i+2]=128+v; d[i+3]=255; }
            gCtx.putImageData(iD, 0, 0); tCtx.save(); tCtx.globalCompositeOperation = 'overlay';
            tCtx.fillStyle = tCtx.createPattern(gC, 'repeat'); tCtx.fillRect(0, 0, w, h); tCtx.restore();
        }

        function rotatePoint(x, y, cx, cy, angle) {
            const cos = Math.cos(angle); const sin = Math.sin(angle);
            const dx = x - cx; const dy = y - cy;
            return { x: cx + dx * cos - dy * sin, y: cy + dx * sin + dy * cos };
        }

        function getHandleUnderMouse(mx, my) {
            if (!selectionState.active) return null;
            const r = selectionState.rect; const cx = r.x+r.w/2, cy = r.y+r.h/2;
            const p = rotatePoint(mx, my, cx, cy, -selectionState.rotation);
            const hs = 12 / viewState.scale;
            if (Math.abs(p.x-r.x)<hs && Math.abs(p.y-r.y)<hs) return 'tl';
            if (Math.abs(p.x-(r.x+r.w))<hs && Math.abs(p.y-r.y)<hs) return 'tr';
            if (Math.abs(p.x-(r.x+r.w))<hs && Math.abs(p.y-(r.y+r.h))<hs) return 'br';
            if (Math.abs(p.x-r.x)<hs && Math.abs(p.y-(r.y+r.h))<hs) return 'bl';
            if (Math.abs(p.x-cx)<hs && Math.abs(p.y-(r.y-25/viewState.scale))<hs) return 'rotate';
            return null;
        }

        function isInsideRect(mx, my) {
            if (!selectionState.active) return false;
            const r = selectionState.rect; const cx = r.x+r.w/2, cy = r.y+r.h/2;
            const p = rotatePoint(mx, my, cx, cy, -selectionState.rotation);
            return p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h;
        }

        // --- Window Event Listeners for Zoom ---
        // dropZoneだけでなくwindow全体でホイールを監視し、ターゲットがキャンバスエリア内ならズーム
        window.addEventListener('wheel', (e) => {
            if (!isImageLoaded) return;
            // ターゲットがdropZoneまたはその子要素の場合のみズーム
            if (dropZone.contains(e.target)) {
                e.preventDefault();
                const delta = -Math.sign(e.deltaY);
                const zoomStep = 0.1;
                let newScale = viewState.scale;

                if (delta > 0) {
                    newScale *= (1 + zoomStep);
                } else {
                    newScale /= (1 + zoomStep);
                }
                
                viewState.scale = Math.min(Math.max(newScale, 0.05), 50);
                updateCanvasTransform();
            }
        }, { passive: false });


        dropZone.addEventListener('dragover', (e) => e.preventDefault());
        dropZone.addEventListener('drop', (e) => { e.preventDefault(); if (e.dataTransfer.files.length > 0) loadFile(e.dataTransfer.files[0]); });
        uploadInput.addEventListener('change', (e) => { if (e.target.files.length > 0) loadFile(e.target.files[0]); });

        canvas.addEventListener('mousedown', (e) => {
            if (!isImageLoaded) return;
            if (currentMode === 'hand' || e.button === 1 || e.spaceKey) { viewState.isDragging = true; viewState.lastX = e.clientX; viewState.lastY = e.clientY; canvas.style.cursor = 'grabbing'; return; }
            const br = canvas.getBoundingClientRect(); const mx = (e.clientX - br.left) / viewState.scale, my = (e.clientY - br.top) / viewState.scale;
            const hnd = getHandleUnderMouse(mx, my);
            if (hnd) {
                selectionState.dragMode = hnd === 'rotate' ? 'rotate' : 'resize-' + hnd; selectionState.active = true;
                const rect = selectionState.rect; const cx = rect.x+rect.w/2, cy = rect.y+rect.h/2;
                let ax = rect.x, ay = rect.y;
                if (hnd === 'tl') { ax = rect.x + rect.w; ay = rect.y + rect.h; } else if (hnd === 'tr') { ax = rect.x; ay = rect.y + rect.h; } else if (hnd === 'bl') { ax = rect.x + rect.w; ay = rect.y; } else if (hnd === 'br') { ax = rect.x; ay = rect.y; }
                selectionState.anchorGlobal = rotatePoint(ax, ay, cx, cy, selectionState.rotation);
            } else if (isInsideRect(mx, my)) { selectionState.dragMode = 'move'; selectionState.active = true; } 
            else { selectionState.dragMode = 'create'; selectionState.active = false; selectionState.shape = (currentMode === 'circle') ? 'circle' : 'rect'; selectionState.rotation = 0; actionBar.classList.add('hidden'); }
            selectionState.startX = mx; selectionState.startY = my; selectionState.initialRect = { ...selectionState.rect }; selectionState.initialRotation = selectionState.rotation;
            if (selectionState.dragMode === 'create') selectionState.rect = { x: mx, y: my, w: 0, h: 0 };
        });

        window.addEventListener('mousemove', (e) => {
            if (!isImageLoaded) return;
            if (viewState.isDragging) { const dx = e.clientX - viewState.lastX, dy = e.clientY - viewState.lastY; viewState.x += dx; viewState.y += dy; viewState.lastX = e.clientX; viewState.lastY = e.clientY; updateCanvasTransform(); return; }
            const br = canvas.getBoundingClientRect(); const mx = (e.clientX - br.left) / viewState.scale, my = (e.clientY - br.top) / viewState.scale;
            const hnd = getHandleUnderMouse(mx, my);
            if (hnd) canvas.style.cursor = hnd === 'rotate' ? 'alias' : (hnd === 'tl' || hnd === 'br' ? 'nwse-resize' : 'nesw-resize');
            else if (isInsideRect(mx, my)) canvas.style.cursor = 'move';
            else canvas.style.cursor = 'crosshair';
            if (!selectionState.dragMode) return;
            if (selectionState.dragMode === 'rotate') { const r = selectionState.rect, cx = r.x+r.w/2, cy = r.y+r.h/2; selectionState.rotation = Math.atan2(my - cy, mx - cx) + Math.PI / 2; render(); return; }
            if (selectionState.dragMode === 'move') { selectionState.rect.x = selectionState.initialRect.x + (mx - selectionState.startX); selectionState.rect.y = selectionState.initialRect.y + (my - selectionState.startY); } 
            else if (selectionState.dragMode === 'create') {
                let w = mx - selectionState.startX, h = my - selectionState.startY;
                const ratio = (currentMode === 'crop') ? (aspectRatioSelect.value === 'free' ? null : (aspectRatioSelect.value === 'original' ? initialCleanImage.width / initialCleanImage.height : parseFloat(aspectRatioSelect.value.split(':')[0]) / parseFloat(aspectRatioSelect.value.split(':')[1]))) : null;
                if (ratio) { if (Math.abs(w/ratio) < Math.abs(h)) h = w/ratio; else w = h*ratio; } else if (e.shiftKey) { const size = Math.max(Math.abs(w), Math.abs(h)); w = w >= 0 ? size : -size; h = h >= 0 ? size : -size; }
                selectionState.rect = { x: w > 0 ? selectionState.startX : selectionState.startX + w, y: h > 0 ? selectionState.startY : selectionState.startY + h, w: Math.abs(w), h: Math.abs(h) };
                selectionState.active = true;
            } else if (selectionState.dragMode.startsWith('resize')) {
                const type = selectionState.dragMode.split('-')[1];
                const rect = selectionState.rect;
                const cx = rect.x + rect.w/2;
                const cy = rect.y + rect.h/2;
                const localM = rotatePoint(mx, my, cx, cy, -selectionState.rotation);
                
                let localLeft = -rect.w/2;
                let localRight = rect.w/2;
                let localTop = -rect.h/2;
                let localBottom = rect.h/2;
                
                const lmx = localM.x - cx;
                const lmy = localM.y - cy;
                
                if (type.includes('l')) localLeft = lmx;
                if (type.includes('r')) localRight = lmx;
                if (type.includes('t')) localTop = lmy;
                if (type.includes('b')) localBottom = lmy;
                
                let newW = localRight - localLeft;
                let newH = localBottom - localTop;
                
                if (newW < 0) { newW = -newW; const tmp = localLeft; localLeft = localRight; localRight = tmp; }
                if (newH < 0) { newH = -newH; const tmp = localTop; localTop = localBottom; localBottom = tmp; }
                
                const newLocalCx = (localLeft + localRight) / 2;
                const newLocalCy = (localTop + localBottom) / 2;
                
                const globalCenterOffset = rotatePoint(cx + newLocalCx, cy + newLocalCy, cx, cy, selectionState.rotation);
                
                selectionState.rect = {
                    x: globalCenterOffset.x - newW/2,
                    y: globalCenterOffset.y - newH/2,
                    w: newW,
                    h: newH
                };
            }
            render();
        });

        window.addEventListener('mouseup', () => {
            if (viewState.isDragging) { viewState.isDragging = false; canvas.style.cursor = currentMode === 'hand' ? 'grab' : 'crosshair'; }
            if (selectionState.dragMode) {
                const mode = selectionState.dragMode;
                selectionState.dragMode = null;
                if (selectionState.rect.w > 5 && selectionState.rect.h > 5) {
                    selectionState.active = true; actionBar.classList.remove('hidden');
                    if (currentMode === 'crop') { actionLabel.textContent = 'トリミング範囲'; localPanelOverlay.classList.remove('opacity-0', 'pointer-events-none'); }
                    else { 
                        actionLabel.textContent = '選択範囲'; 
                        localPanelOverlay.classList.add('opacity-0', 'pointer-events-none'); 
                        // 新規作成時のみリセット
                        if (mode === 'create') resetParams(localParams);
                    }
                } else selectionState.active = false;
                render();
            }
        });

        // AI Modal - Magic Style Logic (Ver.2.14)
        const AI_TAGS = [
            { id: 'bright', label: '明るく', category: 'light', group: 'brightness', params: { brightness: 15, highlights: 10 } },
            { id: 'dark', label: '暗く', category: 'light', group: 'brightness', params: { brightness: -15, shadows: -10, contrast: 5 } },
            { id: 'contrast_high', label: 'くっきり', category: 'light', group: 'contrast', params: { contrast: 15, highlights: 5 } },
            { id: 'soft', label: 'ふんわり', category: 'light', group: 'contrast', params: { contrast: -10, blur: 0.5, brightness: 5, shadows: 10 } },
            { id: 'high_key', label: 'ハイキー', category: 'light', group: 'exposure', params: { brightness: 20, contrast: -5, saturation: -10 } },
            { id: 'low_key', label: 'ローキー', category: 'light', group: 'exposure', params: { brightness: -20, contrast: 15, shadows: -15 } },
            
            { id: 'warm', label: '暖色系', category: 'color', group: 'temp', params: { temperature: -20, sepia: 5 } }, 
            { id: 'cool', label: '寒色系', category: 'color', group: 'temp', params: { temperature: 20, hue: -5 } },
            { id: 'vivid', label: '鮮やか', category: 'color', group: 'saturation', params: { saturation: 20, vibrance: 25, contrast: 5 } },
            { id: 'fade', label: '色褪せ', category: 'color', group: 'saturation', params: { saturation: -20, contrast: -5, brightness: 5 } },
            { id: 'mono', label: 'モノクロ', category: 'color', group: 'saturation', params: { saturation: -100, contrast: 10 } },
            { id: 'pastel', label: 'パステル', category: 'color', group: 'tone', params: { brightness: 10, saturation: -10, vibrance: 20, contrast: -10 } },
            { id: 'matte_color', label: 'マット', category: 'color', group: 'tone', params: { shadows: 30, contrast: -10 } },

            { id: 'retro', label: 'レトロ', category: 'style', params: { sepia: 20, grain: 15, vignette: 15, contrast: -5, temperature: -5 } },
            { id: 'film', label: 'フィルム風', category: 'style', params: { grain: 25, vignette: 20, contrast: 5, brightness: 2, saturation: -10, blur: 0.1 } },
            { id: 'emo', label: 'エモい', category: 'style', params: { temperature: -10, blur: 0.4, contrast: -10, highlights: -15, vignette: 10, vibrance: 10 } },
            { id: 'cyber', label: 'サイバー', category: 'style', params: { contrast: 20, saturation: 10, hue: 10, temperature: 15, highlights: 15 } },
            { id: 'dream', label: '幻想的', category: 'style', params: { blur: 1.2, brightness: 10, vibrance: 15, contrast: -10, highlights: -5 } },
            { id: 'clear', label: '透明感', category: 'style', params: { brightness: 5, contrast: 5, temperature: 5, saturation: 5, vibrance: 10 } },
            { id: 'nostalgia', label: 'ノスタルジー', category: 'style', params: { sepia: 15, temperature: -10, grain: 10, saturation: -15 } },
        ];

        let selectedTags = [];
        let aiParamsBackup = null;

        window.toggleAIMode = function() {
            if (!isImageLoaded) return;
            const sidebarPresets = document.getElementById('sidebar-presets');
            const aiPanel = document.getElementById('ai-panel');
            const leftSidebar = document.getElementById('left-sidebar');
            const btnMagic = document.getElementById('btn-magic-style');
            
            if (aiPanel.classList.contains('hidden-content')) {
                aiParamsBackup = JSON.parse(JSON.stringify(globalParams));
                sidebarPresets.classList.remove('active-content');
                sidebarPresets.classList.add('hidden-content');
                
                setTimeout(() => {
                    sidebarPresets.style.display = 'none';
                    aiPanel.style.display = 'flex';
                    setTimeout(() => {
                        aiPanel.classList.remove('hidden-content');
                        aiPanel.classList.add('active-content');
                    }, 10);
                }, 200);

                btnMagic.classList.add('border-blue-500', 'bg-blue-900/30', 'text-blue-300');
                leftSidebar.style.width = '18rem'; 
                renderAITags();
            } else {
                closeAIModal(true);
            }
        };

        function closeAIModal(apply = true) {
            const sidebarPresets = document.getElementById('sidebar-presets');
            const aiPanel = document.getElementById('ai-panel');
            const leftSidebar = document.getElementById('left-sidebar');
            const btnMagic = document.getElementById('btn-magic-style');

            if (apply) {
                saveHistoryState();
            }

            aiPanel.classList.remove('active-content');
            aiPanel.classList.add('hidden-content');

            setTimeout(() => {
                aiPanel.style.display = 'none';
                sidebarPresets.style.display = 'flex';
                setTimeout(() => {
                    sidebarPresets.classList.remove('hidden-content');
                    sidebarPresets.classList.add('active-content');
                }, 10);
            }, 200);

            btnMagic.classList.remove('border-blue-500', 'bg-blue-900/30', 'text-blue-300');
            leftSidebar.style.width = '5rem';
            aiParamsBackup = null;
        }

        function renderAITags() {
            const renderCategory = (cat, containerId) => {
                const container = document.getElementById(containerId);
                container.innerHTML = '';
                AI_TAGS.filter(t => t.category === cat).forEach(tag => {
                    const btn = document.createElement('button');
                    btn.className = `ai-tag px-3 py-1.5 rounded-full border transition ${selectedTags.includes(tag.id) ? 'selected' : ''}`;
                    btn.textContent = tag.label;
                    btn.onclick = () => toggleTag(tag.id);
                    container.appendChild(btn);
                });
            };
            renderCategory('light', 'ai-tags-tone'); 
            renderCategory('color', 'ai-tags-color');
            renderCategory('style', 'ai-tags-mood');

            const strengthSlider = document.getElementById('ai-strength');
            document.getElementById('ai-strength-val').textContent = strengthSlider.value + 'x';
            strengthSlider.oninput = (e) => {
                document.getElementById('ai-strength-val').textContent = e.target.value + 'x';
                updateAIPreview();
            };
        }

        function toggleTag(id) {
            const tag = AI_TAGS.find(t => t.id === id);
            if (selectedTags.includes(id)) {
                selectedTags = selectedTags.filter(t => t !== id);
            } else {
                if (tag.group) {
                    const groupTags = AI_TAGS.filter(t => t.group === tag.group).map(t => t.id);
                    selectedTags = selectedTags.filter(t => !groupTags.includes(t));
                }
                selectedTags.push(id);
            }
            renderAITags();
            updateAIPreview();
        }

        window.resetCategory = function(cat) {
            selectedTags = selectedTags.filter(tagId => {
                const tag = AI_TAGS.find(t => t.id === tagId);
                return tag.category !== cat;
            });
            renderAITags();
            updateAIPreview();
        };

        function updateAIPreview() {
            if (!aiParamsBackup) return;
            const strength = parseFloat(document.getElementById('ai-strength').value);
            Object.assign(globalParams, aiParamsBackup); 
            
            selectedTags.forEach(tagId => {
                const tag = AI_TAGS.find(t => t.id === tagId);
                if (tag) {
                    Object.keys(tag.params).forEach(key => {
                        if (globalParams.hasOwnProperty(key)) {
                            globalParams[key] += tag.params[key] * strength;
                        }
                    });
                }
            });
            
            updateInputDisplays(globalParams, '');
            render();
        }

        window.applyAI = function() {
            closeAIModal(true);
        };

        const handleCompareOn = (e) => { if(!isImageLoaded) return; e.preventDefault(); render(false, true); };
        const handleCompareOff = (e) => { if(!isImageLoaded) return; render(false, false); };
        compareBtn.addEventListener('mousedown', handleCompareOn);
        compareBtn.addEventListener('touchstart', handleCompareOn);
        compareBtn.addEventListener('mouseleave', handleCompareOff);
        window.addEventListener('mouseup', handleCompareOff);
        window.addEventListener('touchend', handleCompareOff);

        function resetParams(p) { Object.keys(p).forEach(k => p[k] = 0); updateInputDisplays(p, p === localParams ? 'local' : ''); }
        function updateInputDisplays(p, pre) { Object.keys(p).forEach(k => { const id = pre ? pre + k.charAt(0).toUpperCase() + k.slice(1) : k; const s = document.getElementById(id), n = document.getElementById('num-'+id); if (s) s.value = p[k]; if (n) n.value = p[k]; }); }
        
        downloadBtn.addEventListener('click', () => {
            if (!isImageLoaded) return; render(true);
            const now = new Date();
            const ts = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            const link = document.createElement('a'); link.download = `M3-${ts}.jpg`; link.href = canvas.toDataURL('image/jpeg', 0.92); link.click(); render();
        });

        window.applyPreset = (type) => {
            if (!isImageLoaded) return;
            resetParams(globalParams);
            switch(type) {
                case 'bw': globalParams.saturation = -100; globalParams.contrast = 15; globalParams.grain = 20; globalParams.vignette = 20; break;
                case 'warm': globalParams.temperature = -25; globalParams.vibrance = 15; globalParams.sepia = 10; break;
                case 'cool': globalParams.temperature = 25; globalParams.contrast = 10; globalParams.vibrance = 15; globalParams.hue = -5; break;
                case 'film': globalParams.contrast = -10; globalParams.brightness = 5; globalParams.saturation = -10; globalParams.vibrance = -10; globalParams.temperature = -10; globalParams.grain = 35; globalParams.vignette = 30; globalParams.blur = 0.5; break;
                case 'vivid': globalParams.saturation = 20; globalParams.vibrance = 35; globalParams.contrast = 15; break;
                case 'retro': globalParams.temperature = -15; globalParams.contrast = -5; globalParams.saturation = -15; globalParams.sepia = 35; globalParams.grain = 25; globalParams.vignette = 25; break;
                case 'matte': globalParams.saturation = -15; globalParams.contrast = -10; globalParams.shadows = 35; globalParams.vibrance = -10; break;
                case 'dramatic': globalParams.contrast = 25; globalParams.vibrance = 25; globalParams.vignette = 45; globalParams.highlights = 15; globalParams.shadows = -35; globalParams.grain = 20; break;
            }
            saveHistoryState(); updateInputDisplays(globalParams, ''); render();
        };

        // --- My Style Functions ---
        const MY_STYLE_KEY = 'm3-photo-editor-styles';

        function loadMyStyles() {
            const list = document.getElementById('my-style-list');
            list.innerHTML = '';
            try {
                // ローカルストレージが無効な場合のフォールバック（メモリ内）
                let styles;
                try {
                    styles = JSON.parse(localStorage.getItem(MY_STYLE_KEY) || '[]');
                } catch(e) {
                    styles = memoryStyles;
                }
                
                styles.forEach(style => {
                    const btn = document.createElement('div');
                    btn.className = 'mystyle-btn';
                    btn.innerHTML = `
                        <span class="truncate cursor-pointer flex-1 py-2" onclick="applyMyStyle('${style.id}')">${style.name}</span>
                        <button class="mystyle-delete" onclick="deleteMyStyle('${style.id}')" title="削除">
                            <i class="ph ph-trash"></i>
                        </button>
                    `;
                    list.appendChild(btn);
                });
            } catch (e) {
                console.warn('Style load error', e);
            }
        }

        // 保存ボタンイベントリスナー (ID指定)
        window.saveMyStyle = function() {
            if (!isImageLoaded) { alert('画像を読み込んでください'); return; }
            const name = prompt('現在の設定を保存します。\nスタイル名を入力してください:');
            if (!name) return;

            const newStyle = {
                id: Date.now().toString(),
                name: name,
                params: { ...globalParams }
            };

            try {
                // LocalStorage試行
                const styles = JSON.parse(localStorage.getItem(MY_STYLE_KEY) || '[]');
                styles.push(newStyle);
                localStorage.setItem(MY_STYLE_KEY, JSON.stringify(styles));
            } catch (e) {
                // 失敗したらメモリに保存
                console.warn('LocalStorage unavailable, using memory.', e);
                memoryStyles.push(newStyle);
                alert('ブラウザの制限により保存できませんでした。\n一時的にメモリに保存します（リロードすると消えます）。');
            }
            loadMyStyles();
        };

        window.applyMyStyle = (id) => { 
            if (!isImageLoaded) return;
            try {
                let styles;
                try {
                    styles = JSON.parse(localStorage.getItem(MY_STYLE_KEY) || '[]');
                } catch(e) {
                    styles = memoryStyles;
                }

                const style = styles.find(s => s.id === id);
                if (style) {
                    resetParams(globalParams); 
                    Object.assign(globalParams, style.params);
                    saveHistoryState();
                    updateInputDisplays(globalParams, '');
                    render();
                }
            } catch(e) {}
        };

        window.deleteMyStyle = (id) => { 
            if (!confirm('このスタイルを削除しますか？')) return;
            try {
                try {
                    let styles = JSON.parse(localStorage.getItem(MY_STYLE_KEY) || '[]');
                    styles = styles.filter(s => s.id !== id);
                    localStorage.setItem(MY_STYLE_KEY, JSON.stringify(styles));
                } catch(e) {
                    memoryStyles = memoryStyles.filter(s => s.id !== id);
                }
                loadMyStyles();
            } catch(e) {}
        };

        // Initialize My Styles on load
        loadMyStyles();

        updateInputDisplays(globalParams, ''); updateInputDisplays(localParams, 'local');
    </script>
</body>
</html>
